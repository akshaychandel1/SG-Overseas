{"version":3,"file":"browser.global.js","sources":["../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/flatten.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/_internal/compareValues.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/uniq.ts","../src/array/union.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/zip.ts","../src/array/head.ts","../src/error/AbortError.ts","../src/error/TimeoutError.ts","../src/function/noop.ts","../src/function/ary.ts","../src/function/partial.ts","../src/function/partialRight.ts","../src/math/sum.ts","../src/math/mean.ts","../src/object/clone.ts","../src/predicate/isPlainObject.ts","../src/object/flattenObject.ts","../src/object/mapKeys.ts","../src/object/mapValues.ts","../src/predicate/isPrimitive.ts","../src/predicate/isTypedArray.ts","../src/object/cloneDeep.ts","../src/compat/predicate/isObjectLike.ts","../src/object/merge.ts","../src/compat/_internal/tags.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/predicate/isEqual.ts","../src/predicate/isNil.ts","../src/predicate/isLength.ts","../src/promise/delay.ts","../src/promise/timeout.ts","../src/string/capitalize.ts","../src/string/_internal/getWords.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/predicate/isSymbol.ts","../src/compat/_internal/toKey.ts","../src/compat/_internal/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/_internal/isArrayMatch.ts","../src/compat/predicate/isMatch.ts","../src/compat/_internal/isMapMatch.ts","../src/compat/_internal/isSetMatch.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/array/flatten.ts","../src/compat/_internal/isKey.ts","../src/compat/object/set.ts","../src/compat/function/bind.ts","../src/compat/_internal/identity.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/object/mergeWith.ts","../src/function/after.ts","../src/compat/function/ary.ts","../src/function/before.ts","../src/string/camelCase.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/math/clamp.ts","../src/array/compact.ts","../src/compat/array/concat.ts","../src/array/countBy.ts","../src/function/debounce.ts","../src/compat/array/difference.ts","../src/array/drop.ts","../src/array/dropRight.ts","../src/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/compat/string/endsWith.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/array/flatMap.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/flattenDepth.ts","../src/array/forEachRight.ts","../src/array/groupBy.ts","../src/math/inRange.ts","../src/compat/array/indexOf.ts","../src/array/initial.ts","../src/object/invert.ts","../src/compat/predicate/isArray.ts","../src/compat/predicate/isArrayLike.ts","../src/compat/predicate/isBoolean.ts","../src/predicate/isFunction.ts","../src/predicate/isNotNil.ts","../src/predicate/isNull.ts","../src/compat/predicate/isString.ts","../src/array/isSubset.ts","../src/predicate/isUndefined.ts","../src/string/kebabCase.ts","../src/array/keyBy.ts","../src/array/last.ts","../src/string/lowerCase.ts","../src/compat/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/compat/math/max.ts","../src/array/maxBy.ts","../src/math/meanBy.ts","../src/function/memoize.ts","../src/compat/object/merge.ts","../src/compat/math/min.ts","../src/array/minBy.ts","../src/function/negate.ts","../src/object/omit.ts","../src/object/omitBy.ts","../src/function/once.ts","../src/compat/array/orderBy.ts","../src/compat/_internal/getPath.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/array/partition.ts","../src/string/pascalCase.ts","../src/object/pick.ts","../src/object/pickBy.ts","../src/math/range.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/math/round.ts","../src/array/sample.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/array/size.ts","../src/string/snakeCase.ts","../src/array/sortBy.ts","../src/string/startCase.ts","../src/compat/string/startsWith.ts","../src/math/sumBy.ts","../src/array/tail.ts","../src/array/take.ts","../src/array/takeRight.ts","../src/array/takeRightWhile.ts","../src/array/takeWhile.ts","../src/function/throttle.ts","../src/array/toFilled.ts","../src/object/toMerged.ts","../src/function/unary.ts","../src/array/uniqBy.ts","../src/array/unzip.ts","../src/array/unzipWith.ts","../src/promise/withTimeout.ts","../src/array/without.ts","../src/array/xor.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/array/zipObject.ts","../src/compat/array/zipObjectDeep.ts","../src/array/zipWith.ts"],"sourcesContent":["/**\n * Computes the difference between two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements\n * that are present in the first array but not in the second array. It effectively\n * filters out any elements from the first array that also appear in the second array.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\n * from which elements will be compared and filtered.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * Each element in this array will be checked against the first array, and if a match is found,\n * that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the first array but not\n * in the second array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const result = difference(array1, array2);\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\n */\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => !secondSet.has(item));\n}\n","/**\n * Computes the difference between two arrays after mapping their elements through a provided function.\n *\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\n * that are present in the first array but not in the second array, based on the identity calculated\n * by the mapper function.\n *\n * Essentially, it filters out any elements from the first array that, when\n * mapped, match an element in the mapped version of the second array.\n *\n * @template T, U\n * @param {T[]} firstArr - The primary array from which to derive the difference.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * @param {(value: T) => U} mapper - The function to map the elements of both arrays. This function\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\n * mapped identity in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\n */\nexport function differenceBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (value: T) => U): T[] {\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\n\n  return firstArr.filter(item => {\n    return !mappedSecondSet.has(mapper(item));\n  });\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {T[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n */\nexport function differenceWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (const item of arr) {\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n","/**\n * Returns the intersection of two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements that are\n * present in both arrays. It effectively filters out any elements from the first array that\n * are not found in the second array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @returns {T[]} A new array containing the elements that are present in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => {\n    return secondSet.has(item);\n  });\n}\n","/**\n * Returns the intersection of two arrays based on a mapping function.\n *\n * This function takes two arrays and a mapping function. It returns a new array containing\n * the elements from the first array that, when mapped using the provided function, have matching\n * mapped elements in the second array. It effectively filters out any elements from the first array\n * that do not have corresponding mapped values in the second array.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @param {(item: T) => U} mapper - A function to map the elements of both arrays for comparison.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\n */\nexport function intersectionBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (item: T) => U): T[] {\n  const mappedSecondSet = new Set(secondArr.map(mapper));\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n */\nexport function intersectionWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","export function compareValues(a: any, b: any, order: 'asc' | 'desc'): 0 | -1 | 1 {\n  if (a < b) {\n    return order === 'asc' ? -1 : 1;\n  }\n  if (a > b) {\n    return order === 'asc' ? 1 : -1;\n  }\n  return 0;\n}\n","/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(maximum: number): number;\nexport function random(minimum: number, maximum: number): number;\nexport function random(minimum: number, maximum?: number): number {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\n  }\n\n  return Math.random() * (maximum - minimum) + minimum;\n}\n","import { random } from './random.ts';\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(maximum: number): number;\nexport function randomInt(minimum: number, maximum: number): number;\nexport function randomInt(minimum: number, maximum?: number): number {\n  return Math.floor(random(minimum, maximum!));\n}\n","/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: readonly T[]): T[] {\n  return Array.from(new Set(arr));\n}\n","import { uniq } from './uniq.ts';\n\n/**\n * Creates an array of unique values from all given arrays.\n *\n * This function takes two arrays, merges them into a single array, and returns a new array\n * containing only the unique values from the merged array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @returns {T[]} A new array of unique values.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [3, 4, 5];\n * const result = union(array1, array2);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function union<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return uniq(arr1.concat(arr2));\n}\n","/**\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for numbers (modulo comparison)\n * const moduloMapper = (x) => x % 3;\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\n * // Returns [1, 2, 3]\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = (obj) => obj.id;\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\n */\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (const item of [...arr1, ...arr2]) {\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (const item of arr) {\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { uniqWith } from './uniqWith.ts';\n\n/**\n * Creates an array of unique values from two given arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\n * a new array containing only the unique values as determined by the custom equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array of unique values based on the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }];\n * const array2 = [{ id: 2 }, { id: 3 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = unionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\n */\nexport function unionWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areItemsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\n}\n","/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @param {...T[][]} arrs - The arrays to zip together.\n * @param arr1\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n *\n * const arr3 = [true, false];\n * const result2 = zip(arr1, arr2, arr3);\n * // result2 will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\nexport function zip<T, U, V, W>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[]\n): Array<[T, U, V, W]>;\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\n  const result: T[][] = [];\n\n  const maxIndex = Math.max(...arrs.map(x => x.length));\n\n  for (let i = 0; i < maxIndex; i++) {\n    const element: T[] = [];\n\n    for (const arr of arrs) {\n      element.push(arr[i]);\n    }\n\n    result.push(element);\n  }\n\n  return result;\n}\n","/**\n * Returns the first element of an array.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const firstElement = head(arr);\n * // firstElement will be 1\n *\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly [T, ...T[]]): T;\nexport function head<T>(arr: readonly T[]): T | undefined;\nexport function head<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n","/**\n * An error class representing an aborted operation.\n * @augments Error\n */\nexport class AbortError extends Error {\n  constructor(message = 'The operation was aborted') {\n    super(message);\n    this.name = 'AbortError';\n  }\n}\n","/**\n * An error class representing an timeout operation.\n * @augments Error\n */\nexport class TimeoutError extends Error {\n  constructor(message = 'The operation was timed out') {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","/**\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @param {any} guard - Enables use as an iteratee for methods like `map`.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n */\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: Parameters<F>) {\n    return func.apply(this, args.slice(0, n));\n  };\n}\n","/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {F} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const sayHelloTo = partial(greet, 'hello');\n * sayHelloTo('fred');\n * // => 'hello fred'\n *\n * // Partially applied with placeholders.\n * const greetFred = partial(greet, partial.placeholder, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n */\nexport function partial<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\n  return function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    let startIndex = 0;\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partial.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialPlaceholder: unique symbol = Symbol('partial.placeholder');\npartial.placeholder = partialPlaceholder;\n","/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {F} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n *\n * // Partially applied with placeholders.\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\n * sayHelloTo('fred');\n * // => 'hello fred'\n */\nexport function partialRight<F extends (...args: any[]) => any>(func: F, ...partialArgs: any[]): F {\n  return function (this: any, ...providedArgs: any[]) {\n    const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n    const args: any[] = [];\n\n    let providedIndex = 0;\n    for (let i = 0; i < rangeLength; i++) {\n      args.push(providedArgs[providedIndex++]);\n    }\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partialRight.placeholder) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialRightPlaceholder: unique symbol = Symbol('partialRight.placeholder');\npartialRight.placeholder = partialRightPlaceholder;\n","/**\n * Calculates the sum of an array of numbers.\n *\n * This function takes an array of numbers and returns the sum of all the elements in the array.\n *\n * @param {number[]} nums - An array of numbers to be summed.\n * @returns {number} The sum of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = sum(numbers);\n * // result will be 15\n */\nexport function sum(nums: readonly number[]): number {\n  let result = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    result += nums[i];\n  }\n\n  return result;\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = mean(numbers);\n * // result will be 3\n */\nexport function mean(nums: readonly number[]): number {\n  return sum(nums) / nums.length;\n}\n","/**\n * Creates a shallow clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n */\nexport function clone<T>(obj: T): T {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.slice() as T;\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as T;\n  }\n\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as T;\n  }\n\n  if (obj instanceof Map) {\n    const result = new Map();\n    for (const [key, value] of obj) {\n      result.set(key, value);\n    }\n    return result as T;\n  }\n\n  if (obj instanceof Set) {\n    const result = new Set();\n    for (const value of obj) {\n      result.add(value);\n    }\n    return result as T;\n  }\n\n  if (typeof obj === 'object') {\n    const prototype = Object.getPrototypeOf(obj);\n    const result = Object.create(prototype);\n    return Object.assign(result, obj);\n  }\n  return obj;\n}\n\ntype Primitive = null | undefined | string | number | boolean | symbol | bigint;\n\nfunction isPrimitive(value: unknown): value is Primitive {\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * @param {object} object - The value to check.\n * @returns {boolean} - True if the value is a plain object, otherwise false.\n *\n * @example\n * console.log(isPlainObject({})); // true\n * console.log(isPlainObject([])); // false\n * console.log(isPlainObject(null)); // false\n * console.log(isPlainObject(Object.create(null))); // true\n * console.log(Buffer.from('hello, world')); // false\n */\nexport function isPlainObject(object: object): boolean {\n  if (typeof object !== 'object') {\n    return false;\n  }\n\n  if (object == null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(object) === null) {\n    return true;\n  }\n\n  if (object.toString() !== '[object Object]') {\n    return false;\n  }\n\n  let proto = object;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(object) === proto;\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\n/**\n * Flattens a nested object into a single level object with dot-separated keys.\n *\n * @param {object} object - The object to flatten.\n * @returns {Record<string, any>} - The flattened object.\n *\n * @example\n * const nestedObject = {\n *   a: {\n *     b: {\n *       c: 1\n *     }\n *   },\n *   d: [2, 3]\n * };\n *\n * const flattened = flattenObject(nestedObject);\n * console.log(flattened);\n * // Output:\n * // {\n * //   'a.b.c': 1,\n * //   'd.0': 2,\n * //   'd.1': 3\n * // }\n */\nexport function flattenObject(object: object): Record<string, any> {\n  return flattenObjectImpl(object);\n}\n\nfunction flattenObjectImpl(object: object, prefix = ''): Record<string, any> {\n  const result: Record<string, any> = {};\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (object as any)[key];\n\n    const prefixedKey = prefix ? `${prefix}.${key}` : key;\n\n    if (isPlainObject(value) && Object.keys(value).length > 0) {\n      Object.assign(result, flattenObjectImpl(value, prefixedKey));\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      for (let index = 0; index < value.length; index++) {\n        result[`${prefixedKey}.${index}`] = value[index];\n      }\n      continue;\n    }\n\n    result[prefixedKey] = value;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n * @template K2 - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\n  object: T,\n  getNewKey: (value: T[K1], key: K1, object: T) => K2\n): Record<K2, T[K1]> {\n  const result = {} as Record<K2, T[K1]>;\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K1;\n    const value = object[key];\n\n    result[getNewKey(value, key, object)] = value as any;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K;\n    const value = object[key];\n\n    result[key] = getNewValue(value, key, object);\n  }\n\n  return result;\n}\n","/**\n * Checks whether a value is a JavaScript primitive.\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\n *\n * @param {unknown} value The value to check.\n * @returns {value is\n *   | null\n *   | undefined\n *   | string\n *   | number\n *   | boolean\n *   | symbol\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\n */\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n","/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *   | Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n */\nexport function isTypedArray(\n  x: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return (\n    x instanceof Uint8Array ||\n    x instanceof Uint8ClampedArray ||\n    x instanceof Uint16Array ||\n    x instanceof Uint32Array ||\n    x instanceof BigUint64Array ||\n    x instanceof Int8Array ||\n    x instanceof Int16Array ||\n    x instanceof Int32Array ||\n    x instanceof BigInt64Array ||\n    x instanceof Float32Array ||\n    x instanceof Float64Array\n  );\n}\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepImpl(obj);\n}\n\nfunction cloneDeepImpl<T>(obj: T, stack = new Map<any, any>()): T {\n  if (isPrimitive(obj)) {\n    return obj as T;\n  }\n\n  if (stack.has(obj)) {\n    return stack.get(obj) as T;\n  }\n\n  if (Array.isArray(obj)) {\n    const result: any = new Array(obj.length);\n    stack.set(obj, result);\n\n    for (let i = 0; i < obj.length; i++) {\n      result[i] = cloneDeepImpl(obj[i], stack);\n    }\n\n    // For RegExpArrays\n    if (Object.prototype.hasOwnProperty.call(obj, 'index')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.index = obj.index;\n    }\n    if (Object.prototype.hasOwnProperty.call(obj, 'input')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.input = obj.input;\n    }\n\n    return result as T;\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as T;\n  }\n\n  if (obj instanceof RegExp) {\n    const result = new RegExp(obj.source, obj.flags);\n\n    result.lastIndex = obj.lastIndex;\n\n    return result as T;\n  }\n\n  if (obj instanceof Map) {\n    const result = new Map();\n    stack.set(obj, result);\n\n    for (const [key, value] of obj.entries()) {\n      result.set(key, cloneDeepImpl(value, stack));\n    }\n\n    return result as T;\n  }\n\n  if (obj instanceof Set) {\n    const result = new Set();\n    stack.set(obj, result);\n\n    for (const value of obj.values()) {\n      result.add(cloneDeepImpl(value, stack));\n    }\n\n    return result as T;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return obj.subarray() as T;\n  }\n\n  if (isTypedArray(obj)) {\n    const result = new (Object.getPrototypeOf(obj).constructor)(obj.length);\n    stack.set(obj, result);\n\n    for (let i = 0; i < obj.length; i++) {\n      result[i] = cloneDeepImpl(obj[i], stack);\n    }\n\n    return result as T;\n  }\n\n  if (obj instanceof ArrayBuffer || (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\n    return obj.slice(0) as T;\n  }\n\n  if (obj instanceof DataView) {\n    const result = new DataView(obj.buffer.slice(0));\n    stack.set(obj, result);\n\n    copyProperties(result, obj, stack);\n\n    return result as T;\n  }\n\n  // For legacy NodeJS support\n  if (typeof File !== 'undefined' && obj instanceof File) {\n    const result = new File([obj], obj.name, { type: obj.type });\n    stack.set(obj, result);\n\n    copyProperties(result, obj, stack);\n\n    return result as T;\n  }\n\n  if (obj instanceof Blob) {\n    const result = new Blob([obj], { type: obj.type });\n    stack.set(obj, result);\n\n    copyProperties(result, obj, stack);\n\n    return result as T;\n  }\n\n  if (obj instanceof Error) {\n    const result = new (obj.constructor as { new (): Error })();\n    stack.set(obj, result);\n\n    result.message = obj.message;\n    result.name = obj.name;\n    result.stack = obj.stack;\n    result.cause = obj.cause;\n\n    copyProperties(result, obj, stack);\n\n    return result as T;\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    const result = {};\n    stack.set(obj, result);\n\n    copyProperties(result, obj, stack);\n\n    return result as T;\n  }\n\n  return obj;\n}\n\n// eslint-disable-next-line\nexport function copyProperties(target: any, source: any, stack?: Map<any, any>): void {\n  const keys = Object.keys(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\n\n    if (descriptor?.writable || descriptor?.set) {\n      target[key] = cloneDeepImpl(source[key], stack);\n    }\n  }\n}\n","/**\n * Checks if the given value is object-like.\n *\n * A value is object-like if its type is object and it is not null.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\n *\n * @template T - The type of value.\n * @param {T} value - The value to test if it is an object-like.\n * @returns {value is Extract<T, object>} `true` if the value is an object-like, `false` otherwise.\n *\n * @example\n * const value1 = { a: 1 };\n * const value2 = [1, 2, 3];\n * const value3 = 'abc';\n * const value4 = () => {};\n * const value5 = null;\n *\n * console.log(isObjectLike(value1)); // true\n * console.log(isObjectLike(value2)); // true\n * console.log(isObjectLike(value3)); // false\n * console.log(isObjectLike(value4)); // false\n */\n\nexport function isObjectLike(value: unknown): value is object {\n  return typeof value === 'object' && value !== null;\n}\n","import { isObjectLike } from '../compat/predicate/isObjectLike.ts';\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function mutates the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The source object whose properties will be merged into the target object.\n * @returns {T & S} The updated target object with properties from the source object merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<T, S>(target: T, source: S): T & S;\nexport function merge(target: any, source: any) {\n  const sourceKeys = Object.keys(source);\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    const sourceValue = source[key];\n    const targetValue = target[key];\n\n    if (Array.isArray(sourceValue)) {\n      target[key] = merge(targetValue ?? [], sourceValue);\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n      target[key] = merge(targetValue ?? {}, sourceValue);\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","export const regexpTag = '[object RegExp]';\nexport const stringTag = '[object String]';\nexport const numberTag = '[object Number]';\nexport const booleanTag = '[object Boolean]';\nexport const argumentsTag = '[object Arguments]';\nexport const symbolTag = '[object Symbol]';\nexport const dateTag = '[object Date]';\nexport const mapTag = '[object Map]';\nexport const setTag = '[object Set]';\nexport const arrayTag = '[object Array]';\nexport const functionTag = '[object Function]';\nexport const arrayBufferTag = '[object ArrayBuffer]';\nexport const objectTag = '[object Object]';\nexport const errorTag = '[object Error]';\nexport const dataViewTag = '[object DataView]';\nexport const uint8ArrayTag = '[object Uint8Array]';\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nexport const uint16ArrayTag = '[object Uint16Array]';\nexport const uint32ArrayTag = '[object Uint32Array]';\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\nexport const int8ArrayTag = '[object Int8Array]';\nexport const int16ArrayTag = '[object Int16Array]';\nexport const int32ArrayTag = '[object Int32Array]';\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\nexport const float32ArrayTag = '[object Float32Array]';\nexport const float64ArrayTag = '[object Float64Array]';\n","export function getSymbols(object: any) {\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\n  );\n}\n","/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {T} value The value to query.\n * @returns {string} Returns the `Object.prototype.toString.call` result.\n */\nexport function getTag<T>(value: T) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n  return Object.prototype.toString.call(value);\n}\n","import {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  bigInt64ArrayTag,\n  bigUint64ArrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  errorTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  functionTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  int8ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport { isPlainObject } from './isPlainObject.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Checks if two values are equal, including support for `Date`, `RegExp`, and deep object comparison.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @returns {boolean} `true` if the values are equal, otherwise `false`.\n *\n * @example\n * isEqual(1, 1); // true\n * isEqual({ a: 1 }, { a: 1 }); // true\n * isEqual(/abc/g, /abc/g); // true\n * isEqual(new Date('2020-01-01'), new Date('2020-01-01')); // true\n * isEqual([1, 2, 3], [1, 2, 3]); // true\n */\nexport function isEqual(a: any, b: any): boolean {\n  if (typeof a === typeof b) {\n    switch (typeof a) {\n      case 'bigint':\n      case 'string':\n      case 'boolean':\n      case 'symbol':\n      case 'undefined': {\n        return a === b;\n      }\n      case 'number': {\n        return a === b || Object.is(a, b);\n      }\n      case 'function': {\n        return a === b;\n      }\n      case 'object': {\n        return areObjectsEqual(a, b);\n      }\n    }\n  }\n\n  return areObjectsEqual(a, b);\n}\n\nfunction areObjectsEqual(a: any, b: any, stack?: Map<any, any>) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  let aTag = getTag(a);\n  let bTag = getTag(b);\n\n  if (aTag === argumentsTag) {\n    aTag = objectTag;\n  }\n\n  if (bTag === argumentsTag) {\n    bTag = objectTag;\n  }\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case stringTag:\n      return a.toString() === b.toString();\n\n    case numberTag: {\n      const x = a.valueOf();\n      const y = b.valueOf();\n\n      return x === y || (Number.isNaN(x) && Number.isNaN(y));\n    }\n\n    case booleanTag:\n    case dateTag:\n    case symbolTag:\n      return Object.is(a.valueOf(), b.valueOf());\n\n    case regexpTag: {\n      return a.source === b.source && a.flags === b.flags;\n    }\n\n    case functionTag: {\n      return a === b;\n    }\n  }\n\n  stack = stack ?? new Map();\n\n  const aStack = stack.get(a);\n  const bStack = stack.get(b);\n\n  if (aStack != null && bStack != null) {\n    return aStack === b;\n  }\n\n  stack.set(a, b);\n  stack.set(b, a);\n\n  try {\n    switch (aTag) {\n      case mapTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        for (const [key, value] of a.entries()) {\n          if (!b.has(key) || !areObjectsEqual(value, b.get(key), stack)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case setTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        const aValues = Array.from(a.values());\n        const bValues = Array.from(b.values());\n\n        for (let i = 0; i < aValues.length; i++) {\n          const aValue = aValues[i];\n          const index = bValues.findIndex(bValue => {\n            return areObjectsEqual(aValue, bValue, stack);\n          });\n\n          if (index === -1) {\n            return false;\n          }\n\n          bValues.splice(index, 1);\n        }\n\n        return true;\n      }\n\n      case arrayTag:\n      case uint8ArrayTag:\n      case uint8ClampedArrayTag:\n      case uint16ArrayTag:\n      case uint32ArrayTag:\n      case bigUint64ArrayTag:\n      case int8ArrayTag:\n      case int16ArrayTag:\n      case int32ArrayTag:\n      case bigInt64ArrayTag:\n      case float32ArrayTag:\n      case float64ArrayTag: {\n        // Buffers are also treated as [object Uint8Array]s.\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n          return false;\n        }\n\n        if (a.length !== b.length) {\n          return false;\n        }\n\n        for (let i = 0; i < a.length; i++) {\n          if (!areObjectsEqual(a[i], b[i], stack)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case arrayBufferTag: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack);\n      }\n\n      case dataViewTag: {\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n          return false;\n        }\n\n        return areObjectsEqual(a.buffer, b.buffer, stack);\n      }\n\n      case errorTag: {\n        return a.name === b.name && a.message === b.message;\n      }\n\n      case objectTag: {\n        const areEqualInstances =\n          areObjectsEqual(a.constructor, b.constructor, stack) || (isPlainObject(a) && isPlainObject(b));\n\n        if (!areEqualInstances) {\n          return false;\n        }\n\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\n\n        if (aKeys.length !== bKeys.length) {\n          return false;\n        }\n\n        for (let i = 0; i < aKeys.length; i++) {\n          const propKey = aKeys[i];\n          const aProp = (a as any)[propKey];\n\n          if (!Object.prototype.hasOwnProperty.call(b, propKey)) {\n            return false;\n          }\n\n          const bProp = (b as any)[propKey];\n\n          if (!areObjectsEqual(aProp, bProp, stack)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      default: {\n        return false;\n      }\n    }\n  } finally {\n    stack.delete(a);\n    stack.delete(b);\n  }\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: unknown): x is null | undefined {\n  return x == null;\n}\n","/**\n * Checks if a given value is a valid length.\n *\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\n * It returns `true` if the value is a valid length, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\n * argument to a valid length (`number`).\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n *\n * @example\n * isLength(0); // true\n * isLength(42); // true\n * isLength(-1); // false\n * isLength(1.5); // false\n * isLength(Number.MAX_SAFE_INTEGER); // true\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\n */\nexport function isLength(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n","import { AbortError } from '../error/AbortError.ts';\n\ninterface DelayOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n *\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\n * with async/await to pause execution.\n *\n * @param {number} ms - The number of milliseconds to delay.\n * @param {DelayOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\n *\n * @example\n * async function foo() {\n *   console.log('Start');\n *   await delay(1000); // Delays execution for 1 second\n *   console.log('End');\n * }\n *\n * foo();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const { signal } = controller;\n *\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\n * try {\n *   await delay(100, { signal });\n *  } catch (error) {\n *   console.error(error); // Will log 'AbortError'\n *  }\n * }\n */\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const abortError = () => {\n      reject(new AbortError());\n    };\n\n    const abortHandler = () => {\n      clearTimeout(timeoutId);\n      abortError();\n    };\n\n    if (signal?.aborted) {\n      return abortError();\n    }\n\n    const timeoutId = setTimeout(resolve, ms);\n\n    signal?.addEventListener('abort', abortHandler, { once: true });\n  });\n}\n","import { delay } from './delay.ts';\nimport { TimeoutError } from '../error/TimeoutError.ts';\n\n/**\n * Returns a promise that rejects with a `TimeoutError` after a specified delay.\n *\n * @param {number} ms - The delay duration in milliseconds.\n * @returns {Promise<void>} A promise that rejects with a `TimeoutError` after the specified delay.\n * @throws {TimeoutError} Throws a `TimeoutError` after the specified delay.\n */\nexport async function timeout(ms: number): Promise<never> {\n  await delay(ms);\n  throw new TimeoutError();\n}\n","/**\n * Converts the first character of string to upper case and the remaining to lower case.\n *\n * @template T - Literal type of the string.\n * @param {T} str - The string to be converted to uppercase.\n * @returns {Capitalize<T>} - The capitalized string.\n *\n * @example\n * const result = capitalize('fred') // returns 'Fred'\n * const result2 = capitalize('FRED') // returns 'Fred'\n */\n\nexport const capitalize = <T extends string>(str: T): Capitalize<T> => {\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\n};\n","/**\n * Regular expression pattern to split strings into words for various case conversions\n *\n * This pattern matchs sequences of characters in a string, considering the following case:\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\n * - Single uppercase letters\n * - Sequences of digis\n *\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\n * a consistent format like snake case.\n *\n * @example\n * const matches = 'camelCaseHTTPRequest'.match(CASE_SPLIT_PATTERN);\n * // matchs: ['camel', 'Case', 'HTTP', 'Request']\n */\nconst CASE_SPLIT_PATTERN = /[A-Z]?[a-z]+|[0-9]+|[A-Z]+(?![a-z])/g;\n\nexport function getWords(str: string): string[] {\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\n}\n","const IS_PLAIN = /^\\w*$/;\nconst IS_DEEP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n\n/**\n * Checks if a given key is a deep key.\n *\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\n *\n * @param {PropertyKey} key - The key to check.\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\n *\n * Examples:\n *\n * isDeepKey('a.b') // true\n * isDeepKey('a[b]') // true\n * isDeepKey('a') // false\n * isDeepKey(123) // false\n * isDeepKey('a.b.c') // true\n * isDeepKey('a[b][c]') // true\n */\nexport function isDeepKey(key: PropertyKey): boolean {\n  switch (typeof key) {\n    case 'number':\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return !IS_PLAIN.test(key) && IS_DEEP.test(key);\n    }\n  }\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n * @example\n * isSymbol(Symbol.iterator);\n * // => true\n *\n * isSymbol('abc');\n * // => false\n */\nexport function isSymbol(value?: unknown): value is symbol {\n  return typeof value === 'symbol' || (value != null && value instanceof Symbol);\n}\n","import { isSymbol } from '../predicate/isSymbol';\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nexport function toKey(value: unknown) {\n  if (typeof value === 'string' || isSymbol(value)) {\n    return value;\n  }\n\n  if (Object.is(value?.valueOf(), -0)) {\n    return '-0';\n  }\n\n  return `${value}`;\n}\n","/**\n * Converts a deep key string into an array of path segments.\n *\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\n *\n * @param {string} deepKey - The deep key string to convert.\n * @returns {string[]} An array of strings, each representing a segment of the path.\n *\n * Examples:\n *\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\n * toPath('') // Returns []\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\n */\nexport function toPath(deepKey: string): string[] {\n  const ESCAPE_REGEXP = /\\\\(\\\\)?/g;\n  const PROPERTY_REGEXP = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' +\n      '|' +\n      // Or match property names within brackets.\n      '\\\\[(?:' +\n      // Match a non-string expression.\n      '([^\"\\'][^[]*)' +\n      '|' +\n      // Or match strings (supports escaping characters).\n      '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n      ')\\\\]' +\n      '|' +\n      // Or match \"\" as the space between consecutive dots or empty brackets.\n      '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))',\n    'g'\n  );\n\n  const result: string[] = [];\n\n  if (deepKey[0] === '.') {\n    result.push('');\n  }\n\n  let match: RegExpExecArray | null;\n  let lastIndex = 0;\n\n  while ((match = PROPERTY_REGEXP.exec(deepKey)) !== null) {\n    let key = match[0];\n    const expr = match[1];\n    const quote = match[2];\n    const substr = match[3];\n\n    if (quote) {\n      key = substr.replace(ESCAPE_REGEXP, '$1');\n    } else if (expr) {\n      key = expr;\n    }\n\n    result.push(key);\n\n    if (PROPERTY_REGEXP.lastIndex === lastIndex) {\n      PROPERTY_REGEXP.lastIndex++;\n    } else {\n      lastIndex = PROPERTY_REGEXP.lastIndex;\n    }\n  }\n\n  return result;\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../_internal/toPath.ts';\nimport type { Get } from './get.types.ts';\n\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K]} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(object: T, path: K | [K]): T[K];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(object: T | null | undefined, path: K | [K]): T[K] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T, D>(\n  object: T | null | undefined,\n  path: K | [K],\n  defaultValue: D\n): Exclude<T[K], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(object: T, path: [K1, K2]): T[K1][K2];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\n  object: T | null | undefined,\n  path: [K1, K2]\n): T[K1][K2] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], D>(\n  object: T | null | undefined,\n  path: [K1, K2],\n  defaultValue: D\n): Exclude<T[K1][K2], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T,\n  path: [K1, K2, K3]\n): T[K1][K2][K3];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T | null | undefined,\n  path: [K1, K2, K3]\n): T[K1][K2][K3] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], D>(\n  object: T | null | undefined,\n  path: [K1, K2, K3],\n  defaultValue: D\n): Exclude<T[K1][K2][K3], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4]} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T, path: [K1, K2, K3, K4]): T[K1][K2][K3][K4];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4] | undefined} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T | null | undefined, path: [K1, K2, K3, K4]): T[K1][K2][K3][K4] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3][K4], undefined> | D} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  D,\n>(object: T | null | undefined, path: [K1, K2, K3, K4], defaultValue: D): Exclude<T[K1][K2][K3][K4], undefined> | D;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T>} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T>, path: number): T;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T | undefined} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n * @template D - The type of the default value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {T | D} - Returns the resolved value.\n */\nexport function get<T, D>(object: Record<number, T> | null | undefined, path: number, defaultValue: D): T | D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning the default value.\n *\n * @template D - The type of the default value.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {D} - Returns the default value.\n */\nexport function get<D>(object: null | undefined, path: PropertyKey, defaultValue: D): D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning undefined.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @returns {undefined} - Returns undefined.\n */\nexport function get(object: null | undefined, path: PropertyKey): undefined;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @returns {string extends P ? any : Get<T, P>} - Returns the resolved value.\n */\nexport function get<T, P extends string>(data: T, path: P): string extends P ? any : Get<T, P>;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n * @template D - The type of the default value.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<Get<T, P>, null | undefined> | D} - Returns the resolved value.\n */\nexport function get<T, P extends string, D = Get<T, P>>(\n  data: T,\n  path: P,\n  defaultValue: D\n): Exclude<Get<T, P>, null | undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} - Returns the resolved value.\n */\nexport function get(object: unknown, path: PropertyKey | readonly PropertyKey[], defaultValue?: unknown): any;\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return defaultValue;\n  }\n\n  let current = object;\n  let index;\n\n  for (index = 0; index < resolvedPath.length && current != null; index++) {\n    const key = toKey(resolvedPath[index]);\n\n    current = current[key];\n  }\n\n  if (current === null && index === resolvedPath.length) {\n    return current;\n  }\n\n  return current ?? defaultValue;\n}\n","import { get } from './get.ts';\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @returns {(object: unknown) => any} - Returns a new function that takes an object and returns the value at the specified path.\n *\n * @example\n * const getObjectValue = property('a.b.c');\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n *\n * @example\n * const getObjectValue = property(['a', 'b', 'c']);\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n */\nexport function property(path: PropertyKey | readonly PropertyKey[]): (object: unknown) => any {\n  return function (object: unknown) {\n    return get(object, path);\n  };\n}\n","import { isMatch } from '../predicate/isMatch.ts';\n\nexport function isArrayMatch(target: unknown, source: readonly unknown[]) {\n  if (source.length === 0) {\n    return true;\n  }\n\n  if (!Array.isArray(target)) {\n    return false;\n  }\n\n  const countedIndex = new Set<number>();\n\n  for (let i = 0; i < source.length; i++) {\n    const sourceItem = source[i];\n    const index = target.findIndex((targetItem, index) => {\n      return isMatch(targetItem, sourceItem) && !countedIndex.has(index);\n    });\n\n    if (index === -1) {\n      return false;\n    }\n\n    countedIndex.add(index);\n  }\n\n  return true;\n}\n","import { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { isArrayMatch } from '../_internal/isArrayMatch.ts';\nimport { isMapMatch } from '../_internal/isMapMatch.ts';\nimport { isSetMatch } from '../_internal/isSetMatch.ts';\n\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {unknown} target - The target value to match against.\n * @param {unknown} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: unknown, source: unknown): boolean;\nexport function isMatch(target: any, source: any): boolean {\n  if (source === target) {\n    return true;\n  }\n\n  switch (typeof source) {\n    case 'object': {\n      if (source == null) {\n        return true;\n      }\n\n      const keys = Object.keys(source as any);\n\n      if (target == null) {\n        if (keys.length === 0) {\n          return true;\n        }\n\n        return false;\n      }\n\n      if (Array.isArray(source)) {\n        return isArrayMatch(target, source);\n      }\n\n      if (source instanceof Map) {\n        return isMapMatch(target, source);\n      }\n\n      if (source instanceof Set) {\n        return isSetMatch(target, source);\n      }\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (!isPrimitive(target) && !(key in target)) {\n          return false;\n        }\n\n        if (source[key] === undefined && target[key] !== undefined) {\n          return false;\n        }\n\n        if (!isMatch(target[key], source[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    case 'function': {\n      if (Object.keys(source).length > 0) {\n        return isMatch(target, { ...source });\n      }\n\n      return false;\n    }\n    default: {\n      return !source;\n    }\n  }\n}\n","import { isMatch } from '../predicate/isMatch.ts';\n\nexport function isMapMatch(target: unknown, source: Map<any, any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Map)) {\n    return false;\n  }\n\n  for (const [key, value] of source.entries()) {\n    if (!isMatch(target.get(key), value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { isArrayMatch } from './isArrayMatch.ts';\n\nexport function isSetMatch(target: unknown, source: Set<any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Set)) {\n    return false;\n  }\n\n  return isArrayMatch([...target], [...source]);\n}\n","import { cloneDeep } from '../../object/cloneDeep.ts';\nimport { isMatch } from './isMatch.ts';\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @param {unknown} source - The source object to create the matcher from.\n * @returns {(target: unknown) => boolean} - Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * const matcher = matches({ a: 1, b: 2 });\n * matcher({ a: 1, b: 2, c: 3 }); // true\n * matcher({ a: 1, c: 3 }); // false\n *\n * @example\n * // Matching arrays\n * const arrayMatcher = matches([1, 2, 3]);\n * arrayMatcher([1, 2, 3, 4]); // true\n * arrayMatcher([4, 5, 6]); // false\n *\n * @example\n * // Matching objects with nested structures\n * const nestedMatcher = matches({ a: { b: 2 } });\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\n * nestedMatcher({ a: { c: 3 } }); // false\n */\nexport function matches(source: unknown): (target: unknown) => boolean {\n  source = cloneDeep(source);\n\n  return (target?: unknown): boolean => {\n    return isMatch(target, source);\n  };\n}\n","import { cloneDeep as cloneDeepToolkit, copyProperties } from '../../object/cloneDeep.ts';\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  if (typeof obj !== 'object') {\n    return cloneDeepToolkit(obj);\n  }\n\n  switch (Object.prototype.toString.call(obj)) {\n    case numberTag:\n    case stringTag:\n    case booleanTag: {\n      // eslint-disable-next-line\n      // @ts-ignore\n      const result = new obj.constructor(obj?.valueOf()) as T;\n      copyProperties(result, obj);\n      return result;\n    }\n\n    case argumentsTag: {\n      const result = {} as any;\n\n      copyProperties(result, obj);\n\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.length = obj.length;\n      // eslint-disable-next-line\n      // @ts-ignore\n      result[Symbol.iterator] = obj[Symbol.iterator];\n\n      return result as T;\n    }\n\n    default: {\n      return cloneDeepToolkit(obj);\n    }\n  }\n}\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\n\nexport function isIndex(value: PropertyKey) {\n  switch (typeof value) {\n    case 'number': {\n      return Number.isInteger(value) && value >= 0 && value < Number.MAX_SAFE_INTEGER;\n    }\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return IS_UNSIGNED_INTEGER.test(value);\n    }\n  }\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if the given value is an arguments object.\n *\n * This function tests whether the provided value is an arguments object or not.\n * It returns `true` if the value is an arguments object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\n *\n * @param {unknown} value - The value to test if it is an arguments object.\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\n *\n * @example\n * const args = (function() { return arguments; })();\n * const strictArgs = (function() { 'use strict'; return arguments; })();\n * const value = [1, 2, 3];\n *\n * console.log(isArguments(args)); // true\n * console.log(isArguments(strictArgs)); // true\n * console.log(isArguments(value)); // false\n */\nexport function isArguments(value?: unknown): value is IArguments {\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { toPath } from '../_internal/toPath.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {object} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: unknown, path: PropertyKey | readonly PropertyKey[]): boolean;\n\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return false;\n  }\n\n  let current = object;\n\n  for (let i = 0; i < resolvedPath.length; i++) {\n    const key = resolvedPath[i];\n\n    // Check if the current key is a direct property of the current object\n    if (current == null || !Object.prototype.hasOwnProperty.call(current, key)) {\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\n\n      if (!isSparseIndex) {\n        return false;\n      }\n    }\n\n    current = current[key];\n  }\n\n  return true;\n}\n","import { toKey } from '../_internal/toKey.ts';\nimport { cloneDeep } from '../object/cloneDeep.ts';\nimport { get } from '../object/get.ts';\nimport { has } from '../object/has.ts';\nimport { isMatch } from './isMatch.ts';\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * The returned function takes a target object and determines if the property at the\n * specified path within the target object is equal to the given value.\n *\n * @param {PropertyKey | PropertyKey[]} property - The property path to check within the target object.\n *     This can be a single property key or an array of property keys.\n * @param {unknown} source - The value to compare against the property value in the target object.\n *\n * @returns {(target: unknown) => boolean} - A function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * // Using a single property key\n * const checkName = matchesProperty('name', 'Alice');\n * console.log(checkName({ name: 'Alice' })); // true\n * console.log(checkName({ name: 'Bob' })); // false\n *\n * // Using an array of property keys\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\n * console.log(checkNested({ address: { city: 'New York' } })); // true\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\n */\nexport function matchesProperty(\n  property: PropertyKey | readonly PropertyKey[],\n  source: unknown\n): (target?: unknown) => boolean {\n  property = Array.isArray(property) ? property : toKey(property);\n  source = cloneDeep(source);\n\n  return function (target?: unknown) {\n    const result = get(target, property as PropertyKey | PropertyKey[]);\n\n    if (result === undefined) {\n      return has(target, property as PropertyKey | PropertyKey[]);\n    }\n\n    if (source === undefined) {\n      return result === undefined;\n    }\n\n    return isMatch(result, source);\n  };\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[] | object} value - The object to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(value: T[] | object, depth = 1 as D): Array<FlatArray<T[], D>> | [] {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  if (!Array.isArray(value)) {\n    return result;\n  }\n\n  const recursive = (arr: T[], currentDepth: number) => {\n    for (const item of arr) {\n      if (\n        currentDepth < flooredDepth &&\n        (Array.isArray(item) ||\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\n      ) {\n        if (Array.isArray(item)) {\n          recursive(item, currentDepth + 1);\n        } else {\n          recursive(Array.from(item as T[]), currentDepth + 1);\n        }\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(value, 0);\n\n  return result;\n}\n","import { isSymbol } from '../predicate/isSymbol';\n\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n/**  Matches any word character (alphanumeric & underscore).*/\nconst regexIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\n * @param {unknown} value The value to check.\n * @param {unknown} object The object to query.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n *\n * @example\n * isKey('a', { a: 1 });\n * // => true\n *\n * isKey('a.b', { a: { b: 2 } });\n * // => false\n */\nexport function isKey(value?: unknown, object?: unknown): boolean {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n\n  return (\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\n    (object != null && Object.hasOwn(object, value as PropertyKey))\n  );\n}\n","import { isIndex } from '../_internal/isIndex.ts';\nimport { toPath } from '../_internal/toPath.ts';\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {Settable} obj - The object to modify.\n * @param {Path} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T>(obj: object, path: PropertyKey | readonly PropertyKey[], value: unknown): T;\nexport function set<T extends object>(obj: T, path: PropertyKey | readonly PropertyKey[], value: unknown): T {\n  const resolvedPath = Array.isArray(path) ? path : typeof path === 'string' ? toPath(path) : [path];\n\n  let current: any = obj;\n\n  for (let i = 0; i < resolvedPath.length - 1; i++) {\n    const key = resolvedPath[i];\n    const nextKey = resolvedPath[i + 1];\n\n    if (current[key] == null) {\n      current[key] = isIndex(nextKey) ? [] : {};\n    }\n\n    current = current[key];\n  }\n\n  const lastKey = resolvedPath[resolvedPath.length - 1];\n  current[lastKey] = value;\n\n  return obj;\n}\n","/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\n *\n * @param {(...args: any[]) => any} func  The function to bind.\n * @param {any} thisArg  The `this` binding of `func`.\n * @param {any[]} partials  The arguments to be partially applied.\n * @param thisObj\n * @param {...any} partialArgs\n * @returns {(...args: any[]) => any} Returns the new bound function.\n *\n * @example\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n * const object = { user: 'fred' };\n * let bound = bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * bound = bind(greet, object, bind.placeholder, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nexport function bind<F extends (...args: any[]) => any>(func: F, thisObj?: unknown, ...partialArgs: any[]): F {\n  const binded = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bind.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof binded) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...args);\n    }\n\n    return func.apply(thisObj, args);\n  };\n\n  return binded as any as F;\n}\n\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\nbind.placeholder = bindPlaceholder;\n","export function identity<T>(x: T) {\n  return x;\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * A plain object is an object created by the `{}` literal, `new Object()`, or\n * `Object.create(null)`.\n *\n * This function also handles objects with custom\n * `Symbol.toStringTag` properties.\n *\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\n * default string description of objects.\n *\n * @param {unknown} [object] - The value to check.\n * @returns {boolean} - True if the value is a plain object, otherwise false.\n *\n * @example\n * console.log(isPlainObject({})); // true\n * console.log(isPlainObject([])); // false\n * console.log(isPlainObject(null)); // false\n * console.log(isPlainObject(Object.create(null))); // true\n * console.log(isPlainObject(new Map())); // false\n */\nexport function isPlainObject(object?: unknown): boolean {\n  if (typeof object !== 'object') {\n    return false;\n  }\n\n  if (object == null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(object) === null) {\n    return true;\n  }\n\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tag = object[Symbol.toStringTag];\n\n    if (tag == null) {\n      return false;\n    }\n\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n\n    if (isTagReadonly) {\n      return false;\n    }\n\n    return object.toString() === `[object ${tag}]`;\n  }\n\n  let proto = object;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(object) === proto;\n}\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\n\n/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *   | Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n */\nexport function isTypedArray(\n  x?: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return isTypedArrayToolkit(x);\n}\n","import { clone } from '../../object/clone.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { cloneDeep } from './cloneDeep.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The first source object whose properties will be merged into the target object.\n * @param merge\n * @returns {T & S} The updated target object with properties from the source object(s) merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the first source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<T, S>(\n  target: T,\n  source: S,\n  merge: (targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any\n): T & S;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object to be merged into the target object.\n * @param {S2} source2 - The second source object to be merged into the target object.\n * @param merge\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param merge\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\n * @param merge\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n * @template S4 - Type of the fourth source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} any - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @param object\n * @param {...any} otherArgs\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\n\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\n  const sources = otherArgs.slice(0, -1);\n  const merge = otherArgs[otherArgs.length - 1] as (\n    targetValue: any,\n    sourceValue: any,\n    key: string,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any;\n\n  let result = object;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n\n    result = mergeWithDeep(object, source, merge, new Map());\n  }\n\n  return result;\n}\n\nfunction mergeWithDeep(\n  target: any,\n  source: any,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any,\n  stack: Map<any, any>\n) {\n  if (source == null || typeof source !== 'object') {\n    return target;\n  }\n\n  if (stack.has(source)) {\n    return clone(stack.get(source));\n  }\n\n  stack.set(source, target);\n\n  if (Array.isArray(source)) {\n    source = source.slice();\n    for (let i = 0; i < source.length; i++) {\n      source[i] = source[i] ?? undefined;\n    }\n  }\n\n  const sourceKeys = Object.keys(source);\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    let sourceValue = source[key];\n    let targetValue = target[key];\n\n    if (isArguments(sourceValue)) {\n      sourceValue = { ...sourceValue };\n    }\n\n    if (isArguments(targetValue)) {\n      targetValue = { ...targetValue };\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n      sourceValue = cloneDeep(sourceValue);\n    }\n\n    if (Array.isArray(sourceValue)) {\n      targetValue = typeof targetValue === 'object' ? Array.from(targetValue ?? []) : [];\n    }\n\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\n\n    if (merged != null) {\n      target[key] = merged;\n    } else if (Array.isArray(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\n      target[key] = cloneDeep(sourceValue);\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","/**\n * Creates a function that only executes starting from the `n`-th call.\n * The provided function will be invoked starting from the `n`-th call.\n *\n * This is particularly useful for scenarios involving events or asynchronous operations\n * where an action should occur only after a certain number of invocations.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of calls required for `func` to execute.\n * @param {F} func - The function to be invoked.\n * @returns {F} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` starting from the `n`-th call.\n * - Returns `undefined` if fewer than `n` calls have been made.\n * @throws {Error} - Throws an error if `n` is negative.\n * @example\n *\n * const afterFn = after(3, () => {\n *  console.log(\"called\")\n * });\n *\n * // Will not log anything.\n * afterFn()\n * // Will not log anything.\n * afterFn()\n * // Will log 'called'.\n * afterFn()\n */\n\nexport const after = <F extends (...args: any[]) => any>(n: number, func: F): F => {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new Error(`n must be a non-negative integer.`);\n  }\n\n  let counter = 0;\n  return ((...args: Parameters<F>) => {\n    if (++counter >= n) {\n      return func(...args);\n    }\n    return undefined;\n  }) as F;\n};\n","import { ary as aryToolkit } from '../../function/ary.ts';\n\n/**\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param guard\n * @param {number} n - The arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n */\nexport function ary<F extends (...args: any[]) => any>(\n  func: F,\n  n: number = func.length,\n  guard?: unknown\n): (...args: any[]) => ReturnType<F> {\n  if (guard) {\n    n = func.length;\n  }\n\n  if (Number.isNaN(n) || n < 0) {\n    n = 0;\n  }\n\n  return aryToolkit(func, n);\n}\n","/**\n * Creates a function that limits the number of times the given function (`func`) can be called.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of times the returned function is allowed to call `func` before stopping.\n * - If `n` is 0, `func` will never be called.\n * - If `n` is a positive integer, `func` will be called up to `n-1` times.\n * @param {F} func - The function to be called with the limit applied.\n * @returns {F} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` until the `n-1`-th call.\n * - Returns `undefined` if the number of calls reaches or exceeds `n`, stopping further calls.\n * @throws {Error} - Throw an error if `n` is negative.\n * @example\n *\n * const beforeFn = before(3, () => {\n *  console.log(\"called\");\n * })\n *\n * // Will log 'called'.\n * beforeFn();\n *\n * // Will log 'called'.\n * beforeFn();\n *\n * // Will not log anything.\n * beforeFn();\n */\n\nexport const before = <F extends (...args: any[]) => any>(n: number, func: F): F => {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new Error('n must be a non-negative integer.');\n  }\n\n  let counter = 0;\n  return ((...args: Parameters<F>) => {\n    if (++counter < n) {\n      return func(...args);\n    }\n    return undefined;\n  }) as F;\n};\n","import { capitalize } from './capitalize.ts';\nimport { getWords } from './_internal/getWords.ts';\n\n/**\n * Converts a string to camel case.\n *\n * camel case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string} str - The string that is to be changed to camel case.\n * @returns {string} - The converted string to camel case.\n *\n * @example\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\n */\n\nexport function camelCase(str: string): string {\n  const words = getWords(str);\n\n  if (words.length === 0) {\n    return '';\n  }\n\n  const [first, ...rest] = words;\n\n  return `${first.toLowerCase()}${rest.map(word => capitalize(word)).join('')}`;\n}\n","import { chunk as chunkToolkit } from '../../array/chunk.ts';\n\n/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n * @throws {Error} Throws an error if `size` is not a positive integer.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: readonly T[], size = 1): T[][] {\n  size = Math.max(Math.floor(size), 0);\n\n  if (size === 0) {\n    return [];\n  }\n\n  return chunkToolkit(arr, size);\n}\n","/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n * @throws {Error} Throws an error if `size` is not a positive integer.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\n  if (!Number.isInteger(size) || size <= 0) {\n    throw new Error('Size must be an integer greater than zero.');\n  }\n\n  const chunkLength = Math.ceil(arr.length / size);\n  const result: T[][] = Array(chunkLength);\n\n  for (let index = 0; index < chunkLength; index++) {\n    const start = index * size;\n    const end = start + size;\n\n    result[index] = arr.slice(start, end);\n  }\n\n  return result;\n}\n","/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, maximum: number): number;\nexport function clamp(value: number, minimum: number, maximum: number): number;\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (bound2 == null) {\n    return Math.min(value, bound1);\n  }\n\n  return Math.min(Math.max(value, bound1), bound2);\n}\n","type NotFalsey<T> = Exclude<T, false | null | 0 | '' | undefined>;\n\n/**\n * Removes falsey values (false, null, 0, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\n  const result: Array<NotFalsey<T>> = [];\n\n  for (const item of arr) {\n    if (item) {\n      result.push(item as NotFalsey<T>);\n    }\n  }\n\n  return result;\n}\n","import { flatten } from '../../array/flatten.ts';\n\n/**\n * Concatenates multiple arrays and values into a single array.\n *\n * @template T The type of elements in the array.\n * @param {...(T | T[])} values - The values and/or arrays to concatenate.\n * @returns {T[]} A new array containing all the input values.\n *\n * @example\n * // Concatenate individual values\n * concat(1, 2, 3);\n * // returns [1, 2, 3]\n *\n * @example\n * // Concatenate arrays of values\n * concat([1, 2], [3, 4]);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate a mix of individual values and arrays\n * concat(1, [2, 3], 4);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate nested arrays\n * concat([1, [2, 3]], 4);\n * // returns [1, [2, 3], 4]\n */\nexport function concat<T>(...values: Array<T | readonly T[]>): T[] {\n  return flatten(values) as T[];\n}\n","/**\n * Count the occurrences of each item in an array\n * based on a transformation function.\n *\n * This function takes an array and a transformation function\n * that converts each item in the array to a string. It then\n * counts the occurrences of each transformed item and returns\n * an object with the transformed items as keys and the counts\n * as values.\n *\n * @template T - The type of the items in the input array.\n *\n * @param {T[]} arr - The input array to count occurrences.\n * @param {(item: T) => string} mapper - The transformation function that maps each item to a string key.\n * @returns {Record<string, number>} An object containing the transformed items as keys and the\n * counts as values.\n */\nexport function countBy<T>(arr: T[], mapper: (item: T) => string): Record<string, number> {\n  const result: Record<string, number> = {};\n\n  for (const item of arr) {\n    const key = mapper(item);\n\n    result[key] = (result[key] ?? 0) + 1;\n  }\n\n  return result;\n}\n","interface DebounceOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns {F & { cancel: () => void }} A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal }: DebounceOptions = {}\n): F & { cancel: () => void } {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = function (...args: Parameters<F>) {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    if (signal?.aborted) {\n      return;\n    }\n\n    timeoutId = setTimeout(() => {\n      func(...args);\n      timeoutId = null;\n    }, debounceMs);\n  } as F & { cancel: () => void };\n\n  const onAbort = function () {\n    debounced.cancel();\n  };\n\n  debounced.cancel = function () {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  signal?.addEventListener('abort', onAbort, { once: true });\n\n  return debounced;\n}\n","import { difference as differenceToolkit } from '../../array/difference.ts';\nimport { flatten } from '../../array/flatten.ts';\n\nexport function difference<T>(arr: readonly T[], ...values: Array<readonly T[]>): T[] {\n  const arr1 = arr;\n  const arr2 = flatten(values);\n\n  return differenceToolkit(arr1, arr2);\n}\n","/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * // result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.max(itemsCount, 0);\n\n  return arr.slice(itemsCount);\n}\n","/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.min(-itemsCount, 0);\n\n  if (itemsCount === 0) {\n    return arr.slice();\n  }\n\n  return arr.slice(0, itemsCount);\n}\n","/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array from the end and drops elements until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element from the end,\n * and dropping continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRightWhile(array, x => x > 3);\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\n */\nexport function dropRightWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!canContinueDropping(arr[i])) {\n      return arr.slice(0, i + 1);\n    }\n  }\n\n  return [];\n}\n","/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\n  const dropEndIndex = arr.findIndex(item => !canContinueDropping(item));\n  if (dropEndIndex === -1) {\n    return [];\n  }\n\n  return arr.slice(dropEndIndex);\n}\n","/**\n * Checks if a string contains another string at the end of the string.\n *\n * Checks if one string endsWith another string. Optional position parameter to offset searching before a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional position from the start to search up to this index\n * @returns {boolean} - True if the str string ends with the target string.\n *\n * @example\n * const isPrefix = endsWith('fooBar', 'foo') // returns true\n * const isPrefix = endsWith('fooBar', 'bar') // returns false\n * const isPrefix = endsWith('fooBar', 'abc') // returns false\n * const isPrefix = endsWith('fooBar', 'foo', 3) // returns true\n * const isPrefix = endsWith('fooBar', 'abc', 5) // returns false\n */\nexport const endsWith = (str: string, target: string, position: number = str.length): boolean => {\n  return str.endsWith(target, position);\n};\n","import { fill as fillToolkit } from '../../array/fill.ts';\n\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U, S, V\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {S} [start=0] - The start position. Defaults to 0.\n * @param {V} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: unknown[], value?: T): T[];\nexport function fill<T, U, S>(array: Array<T | U>, value: U, start: S): Array<T | U>;\nexport function fill<T, U, S, V>(array: Array<T | U>, value: U, start: S, end: V): Array<T | U>;\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\n  start = Math.floor(start);\n  end = Math.floor(end);\n\n  if (!start) {\n    start = 0;\n  }\n  if (!end) {\n    end = 0;\n  }\n\n  return fillToolkit(array, value, start, end);\n}\n","/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: unknown[], value: T): T[];\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number): Array<T | U>;\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number, end: number): Array<T | U>;\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\n  const length = array.length;\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\n\n  for (let i = finalStart; i < finalEnd; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n","import { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Finds the first item in an array that matches the given predicate function.\n *\n * @template T\n * @param {T[]} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @returns {T | undefined} - The first item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = find(items, (item) => item > 3);\n * console.log(result); // 4\n */\nexport function find<T>(\n  arr: readonly T[],\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\n): T | undefined;\n\n/**\n * Finds the first item in an array that matches the given partial object.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @returns {T | undefined} - The first item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, { name: 'Bob' });\n * console.log(result); // { id: 2, name: 'Bob' }\n */\nexport function find<T>(arr: readonly T[], doesMatch: Partial<T>): T | undefined;\n\n/**\n * Finds the first item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, ['name', 'Alice']);\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): T | undefined;\n\n/**\n * Finds the first item in an array that has a specific property, where the property name is provided as a string.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {string} propertyToCheck - The property name to check.\n * @returns {T | undefined} - The first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = find(items, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(arr: readonly T[], propertyToCheck: string): T | undefined;\n\n/**\n * Finds the first item in an object that matches the given predicate function.\n *\n * @template T\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\n * @param {(item: T[keyof T], index: number, arr: T) => unknown} doesMatch - A function that takes an item, its key, and the object, and returns a truthy value if the item matches the criteria.\n * @returns {T | undefined} - The first property value that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = find(obj, (item) => item > 2);\n * console.log(result); // 3\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T,\n  doesMatch: (item: T[keyof T], index: number, object: T) => unknown\n): T | undefined;\n\n/**\n * Finds the first item in an object that matches the given partial value.\n *\n * @template T\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\n * @param {Partial<T[keyof T]>} doesMatch - A partial value to match against the values of the object.\n * @returns {T | undefined} - The first property value that matches the partial value, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial value\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, { name: 'Bob' });\n * console.log(result); // { id: 2, name: 'Bob' }\n */\nexport function find<T extends Record<string, unknown>>(object: T, doesMatch: Partial<T[keyof T]>): T | undefined;\n\n/**\n * Finds the first item in an object that matches a property with a specific value.\n *\n * @template T\n * @param {readonly T[]} object - The object to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {T | undefined} - The first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = { alice: { id: 1, name: 'Alice' }, bob: { id: 2, name: 'Bob' } };\n * const result = find(items, ['name', 'Alice']);\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T extends Record<string, unknown>>(\n  object: T,\n  doesMatchProperty: [keyof T, unknown]\n): T | undefined;\n\n/**\n * Finds the first item in an object that has a specific property, where the property name is provided as a string.\n *\n * @template T\n * @param {T extends Record<string, unknown> ? T : never} object - The object to search through.\n * @param {string} propertyToCheck - The property name to check.\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T extends Record<string, unknown>>(object: T, propertyToCheck: string): T | undefined;\n\nexport function find<T>(\n  source: readonly T[] | Record<any, any>,\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\n): T | undefined {\n  let values = source;\n\n  if (!Array.isArray(source)) {\n    values = Object.values(source);\n  }\n\n  switch (typeof doesMatch) {\n    case 'function': {\n      if (!Array.isArray(source)) {\n        const entries: any[] = Object.entries(source);\n\n        for (let i = 0; i < entries.length; i++) {\n          const entry = entries[i];\n          const key = entry[0];\n          const value = entry[1];\n\n          if (doesMatch(value, key, source)) {\n            return value;\n          }\n        }\n\n        return undefined;\n      }\n\n      return values.find(doesMatch);\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        return values.find(matchesProperty(key, value));\n      } else {\n        return values.find(matches(doesMatch));\n      }\n    }\n    case 'string': {\n      return values.find(property(doesMatch));\n    }\n  }\n}\n","import { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Finds the index of the first item in an array that matches the given predicate function.\n *\n * @template T\n * @param {T[]} arr - The array to search through.\n * @param {(item: T, index: number, arr: T[]) => unknown} doesMatch - A function that takes an item, its index, and the array, and returns a truthy value if the item matches the criteria.\n * @returns {number} - The index of the first item that matches the predicate, or `undefined` if no match is found.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = find(items, (item) => item > 3);\n * console.log(result); // 4\n */\nexport function findIndex<T>(\n  arr: readonly T[],\n  doesMatch: (item: T, index: number, arr: readonly T[]) => unknown\n): number;\n\n/**\n * Finds the index of the first item in an array that matches the given partial object.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {Partial<T>} doesMatch - A partial object that specifies the properties to match.\n * @returns {number} - The index of the first item that matches the partial object, or `undefined` if no match is found.\n *\n * @example\n * // Using a partial object\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, { name: 'Bob' });\n * console.log(result); // 1\n */\nexport function findIndex<T>(arr: readonly T[], doesMatch: Partial<T>): number;\n\n/**\n * Finds the index of the first item in an array that matches a property with a specific value.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {[keyof T, unknown]} doesMatchProperty - An array where the first element is the property key and the second element is the value to match.\n * @returns {number} - The index of the first item that has the specified property value, or `undefined` if no match is found.\n *\n * @example\n * // Using a property-value pair\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, ['name', 'Alice']);\n * console.log(result); // 0\n */\nexport function findIndex<T>(arr: readonly T[], doesMatchProperty: [keyof T, unknown]): number;\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a string.\n *\n * @template T\n * @param {readonly T[]} arr - The array to search through.\n * @param {string} propertyToCheck - The property name to check.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, 'name');\n * console.log(result); // 0\n */\nexport function findIndex<T>(arr: readonly T[], propertyToCheck: string): number;\n\nexport function findIndex<T>(\n  source: readonly T[],\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | string\n): number {\n  switch (typeof doesMatch) {\n    case 'function': {\n      return source.findIndex(doesMatch);\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        return source.findIndex(matchesProperty(key, value));\n      } else {\n        return source.findIndex(matches(doesMatch));\n      }\n    }\n    case 'string': {\n      return source.findIndex(property(doesMatch));\n    }\n  }\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Maps each element in the array using the iteratee function and flattens the result up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template U - The type of elements within the returned array from the iteratee function.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {(item: T) => U} iteratee - The function that produces the new array elements.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<U[], D>>} The new array with the mapped and flattened elements.\n *\n * @example\n * const arr = [1, 2, 3];\n *\n * flatMap(arr, (item: number) => [item, item]);\n * // [1, 1, 2, 2, 3, 3]\n *\n * flatMap(arr, (item: number) => [[item, item]], 2);\n * // [1, 1, 2, 2, 3, 3]\n */\nexport function flatMap<T, U, D extends number>(\n  arr: readonly T[],\n  iteratee: (item: T) => U,\n  depth = 1 as D\n): Array<FlatArray<U[], D>> {\n  return flatten(\n    arr.map(item => iteratee(item)),\n    depth\n  );\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Utility type for recursively unpacking nested array types to extract the type of the innermost element\n *\n * @example\n * ExtractNestedArrayType<(number | (number | number[])[])[]>\n * // number\n *\n * ExtractNestedArrayType<(boolean | (string | number[])[])[]>\n * // string | number | boolean\n */\ntype ExtractNestedArrayType<T> = T extends ReadonlyArray<infer U> ? ExtractNestedArrayType<U> : T;\n\n/**\n * Flattens all depths of a nested array.\n *\n * @template T - The type of elements within the array.\n * @param {T[] | object} value - The value to flatten.\n * @returns {Array<ExtractNestedArrayType<T>> | []} A new array that has been flattened.\n *\n * @example\n * const value = flattenDeep([1, [2, [3]], [4, [5, 6]]]);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flattenDeep<T>(value: readonly T[] | object): Array<ExtractNestedArrayType<T>> | [] {\n  return flatten(value, Infinity) as Array<ExtractNestedArrayType<T>>;\n}\n","import { flatten } from './flatten.ts';\n\n/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[] | object} value - The value to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flattenDepth<T, D extends number = 1>(\n  value: T[] | object,\n  depth = 1 as D\n): Array<FlatArray<T[], D>> | [] {\n  return flatten(value, depth);\n}\n","/**\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'arr': The array 'forEachRight' was called upon.\n *\n * @example\n * const array = [1, 2, 3];\n * const result: number[] = [];\n *\n * // Use the forEachRight function to iterate through the array and add each element to the result array.\n * forEachRight(array, (value) => {\n *  result.push(value);\n * })\n *\n * console.log(result) // Output: [3, 2, 1]\n */\n\nexport function forEachRight<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => void): void {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const element = arr[i];\n    callback(element, i, arr);\n  }\n}\n","/**\n * Groups the elements of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are arrays of elements that share\n * the same key.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array to group.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\n * share that key.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = groupBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: [\n * //     { category: 'fruit', name: 'apple' },\n * //     { category: 'fruit', name: 'banana' }\n * //   ],\n * //   vegetable: [\n * //     { category: 'vegetable', name: 'carrot' }\n * //   ]\n * // }\n */\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n\n  for (const item of arr) {\n    const key = getKeyFromItem(item);\n\n    if (result[key] == null) {\n      result[key] = [];\n    }\n\n    result[key].push(item);\n  }\n\n  return result;\n}\n","export function inRange(value: number, maximum: number): boolean;\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('The maximum value must be greater than the minimum value.');\n  }\n\n  return minimum <= value && value < maximum;\n}\n","/**\n * Finds the index of the first occurrence of a value in an array.\n *\n * This method is similar to `Array.prototype.indexOf`, but it also finds `NaN` values.\n * It uses strict equality (`===`) to compare elements.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of the value to search for.\n * @param {T[] | null | undefined} array - The array to search.\n * @param {T} searchElement - The value to search for.\n * @param {number} [fromIndex] - The index to start the search at.\n * @returns {number} The index (zero-based) of the first occurrence of the value in the array, or `-1` if the value is not found.\n *\n * @example\n * const array = [1, 2, 3, NaN];\n * indexOf(array, 3); // => 2\n * indexOf(array, NaN); // => 3\n */\nexport function indexOf<T>(array: T[] | null | undefined, searchElement: T, fromIndex?: number): number {\n  if (array == null) {\n    return -1;\n  }\n\n  // `Array.prototype.indexOf` doesn't find `NaN` values, so we need to handle that case separately.\n  if (Number.isNaN(searchElement)) {\n    fromIndex = fromIndex ?? 0;\n\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, array.length + fromIndex);\n    }\n\n    for (let i = fromIndex; i < array.length; i++) {\n      if (Number.isNaN(array[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  // Array.prototype.indexOf already handles `fromIndex < -array.length`, `fromIndex >= array.length` and converts `fromIndex` to an integer, so we don't need to handle those cases here.\n  // And it uses strict equality (===) to compare elements like `lodash/indexOf` does.\n  return array.indexOf(searchElement as T, fromIndex);\n}\n","/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The input array to query.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const newArr = initial(arr);\n * // newArr will be [1, 2, 3]\n *\n * @example\n * const emptyArr: number[] = [];\n * const newEmptyArr = initial(emptyArr);\n * // newEmptyArr will be []\n *\n * @example\n * const singleElementArr = ['only one'];\n * const newSingleElementArr = initial(singleElementArr);\n * // newSingleElementArr will be []\n */\nexport function initial<T>(arr: T[]): T[] {\n  if (arr.length <= 1) {\n    return [];\n  }\n  return arr.slice(0, -1);\n}\n","/**\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\n *\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\n * of the input object's key-value pairs.\n *\n * @template K - Type of the keys in the input object (string, number, symbol)\n * @template V - Type of the values in the input object (string, number, symbol)\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\n * @returns {{ [key in V]: K }} - A new object with keys and values inverted\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\n */\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): { [key in V]: K } {\n  const result = {} as { [key in V]: K };\n\n  const keys = Object.keys(obj) as K[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n    result[value] = key;\n  }\n\n  return result;\n}\n","/**\n * Checks if the given value is an array.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @param {unknown} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray(value1)); // true\n * console.log(isArray(value2)); // false\n * console.log(isArray(value3)); // false\n */\nexport function isArray(value?: unknown): value is any[] {\n  return Array.isArray(value);\n}\n","import { isLength } from '../../predicate/isLength.ts';\n\n/**\n * Checks if `value` is array-like.\n *\n * @param {unknown} value The value to check.\n * @returns {value is ArrayLike<unknown>} Returns `true` if `value` is array-like, else `false`.\n *\n * @example\n * isArrayLike([1, 2, 3]); // true\n * isArrayLike('abc'); // true\n * isArrayLike({ 0: 'a', length: 1 }); // true\n * isArrayLike({}); // false\n * isArrayLike(null); // false\n * isArrayLike(undefined); // false\n */\nexport function isArrayLike(value: unknown): value is ArrayLike<unknown> {\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if the given value is boolean.\n *\n * This function tests whether the provided value is strictly `boolean`.\n * It returns `true` if the value is `boolean`, and `false` otherwise.\n *\n *  This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `boolean`.\n *\n * @param {unknown} x - The Value to test if it is boolean.\n * @returns {x is boolean} True if the value is booelan, false otherwise.\n *\n * @example\n *\n * const value1 = true;\n * const value2 = 0;\n * const value3 = 'abc';\n *\n * console.log(isBoolean(value1)); // true\n * console.log(isBoolean(value2)); // false\n * console.log(isBoolean(value3)); // false\n *\n */\nexport function isBoolean(x: unknown): x is boolean {\n  if (x === true || x === false) {\n    return true;\n  }\n\n  if (typeof x === 'object' && x != null && getTag(x) === '[object Boolean]') {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * Checks if `value` is a function.\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n *\n * @example\n * isFunction(Array.prototype.slice); // true\n * isFunction(async function () {}); // true\n * isFunction(function* () {}); // true\n * isFunction(Proxy); // true\n * isFunction(Int8Array); // true\n */\nexport function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n  return typeof value === 'function';\n}\n","/**\n * Checks if the given value is not null nor undefined.\n *\n * The main use of this function is to be used with TypeScript as a type predicate.\n *\n * @template T - The type of value.\n * @param {T | null | undefined} x - The value to test if it is not null nor undefined.\n * @returns {x is T} True if the value is not null nor undefined, false otherwise.\n *\n * @example\n * // Here the type of `arr` is (number | undefined)[]\n * const arr = [1, undefined, 3];\n * // Here the type of `result` is number[]\n * const result = arr.filter(isNotNil);\n * // result will be [1, 3]\n */\nexport function isNotNil<T>(x: T | null | undefined): x is T {\n  return x !== null && x !== undefined;\n}\n","/**\n * Checks if the given value is null.\n *\n * This function tests whether the provided value is strictly equal to `null`.\n * It returns `true` if the value is `null`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\n *\n * @param {unknown} x - The value to test if it is null.\n * @returns {x is null} True if the value is null, false otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n *\n * console.log(isNull(value1)); // true\n * console.log(isNull(value2)); // false\n * console.log(isNull(value3)); // false\n */\nexport function isNull(x: unknown): x is null {\n  return x === null;\n}\n","import { getTag } from '../_internal/getTag';\n\n/**\n * Checks if a given value is stirng.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\n *\n * @param {unknown} value The value to check if it is string.\n * @returns {value is string} Returns `true` if `value` is a stirng, else `false`.\n *\n * @example\n * const value1 = 'abc';\n * const value2 = 123;\n * const value3 = true;\n *\n * console.log(isString(value1)); // true\n * console.log(isString(value2)); // false\n * console.log(isString(value3)); // false\n */\n\nexport function isString(value: unknown): value is string {\n  if (typeof value === 'string') {\n    return true;\n  }\n\n  if (typeof value === 'object' && value != null && getTag(value) === '[object String]') {\n    return true;\n  }\n\n  return false;\n}\n","import { difference } from '../array/difference.ts';\n\n/**\n * Checks if the `subset` array is entirely contained within the `superset` array.\n *\n *\n * @template T - The type of elements contained in the arrays.\n * @param {T[]} superset - The array that may contain all elements of the subset.\n * @param {T[]} subset - The array to check against the superset.\n * @returns {boolean} - Returns `true` if all elements of the `subset` are present in the `superset`, otherwise returns `false`.\n *\n * @example\n * ```typescript\n * const superset = [1, 2, 3, 4, 5];\n * const subset = [2, 3, 4];\n * isSubset(superset, subset); // true\n * ```\n *\n * @example\n * ```typescript\n * const superset = ['a', 'b', 'c'];\n * const subset = ['a', 'd'];\n * isSubset(superset, subset); // false\n * ```\n */\n\nexport function isSubset<T>(superset: readonly T[], subset: readonly T[]): boolean {\n  return difference(subset, superset).length === 0;\n}\n","/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {unknown} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: unknown): x is undefined {\n  return x === undefined;\n}\n","import { getWords } from './_internal/getWords.ts';\n\n/**\n * Converts a string to kebab case.\n *\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\n *\n * @param {string} str - The string that is to be changed to kebab case.\n * @returns {string} - The converted string to kebab case.\n *\n * @example\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\n */\n\nexport const kebabCase = (str: string): string => {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('-');\n};\n","/**\n * Maps each element of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are the corresponding elements.\n * If there are multiple elements generating the same key, the last element among them is used\n * as the value.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array of elements to be mapped.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T>} An object where keys are mapped to each element of an array.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = keyBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: { category: 'fruit', name: 'banana' },\n * //   vegetable: { category: 'vegetable', name: 'carrot' }\n * // }\n */\nexport function keyBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T> {\n  const result = {} as Record<K, T>;\n\n  for (const item of arr) {\n    const key = getKeyFromItem(item);\n    result[key] = item;\n  }\n\n  return result;\n}\n","/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\n\nexport function last<T>(arr: readonly [...T[], T]): T;\nexport function last<T>(arr: readonly T[]): T | undefined;\nexport function last<T>(arr: readonly T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n","import { getWords } from './_internal/getWords.ts';\n\n/**\n * Converts a string to lower case.\n *\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\n *\n * @param {string} str - The string that is to be changed to lower case.\n * @returns {string} - The converted string to lower case.\n *\n * @example\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\n */\nexport const lowerCase = (str: string): string => {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join(' ');\n};\n","import { mapKeys as mapKeysToolkit } from '../../object/mapKeys.ts';\nimport { identity } from '../_internal/identity.ts';\nimport { property } from './property.ts';\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n *\n * @param {T} object - The object to iterate over.\n * @param {PropertyKey | PropertyKey[]} getNewKey - The path of the property to get to generate the new keys.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object>(\n  object: T,\n  getNewKey?: PropertyKey | readonly PropertyKey[]\n): Record<PropertyKey, T[keyof T]>;\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n * @template K2 - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K1], key: K1, object: T) => K2} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\n  object: T,\n  getNewKey?: (value: T[K1], key: K1, object: T) => K2\n): Record<K2, T[K1]>;\n\nexport function mapKeys<T extends object, K1 extends keyof T, K2 extends PropertyKey>(\n  object: T,\n  getNewKey?: PropertyKey | readonly PropertyKey[] | ((value: T[K1], key: K1, object: T) => K2)\n): Record<K2, T[K1]> {\n  getNewKey = getNewKey ?? (identity as (value: T[K1], key: K1, object: T) => K2);\n\n  switch (typeof getNewKey) {\n    case 'string':\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      return mapKeysToolkit(object, property(getNewKey));\n    }\n    case 'function': {\n      return mapKeysToolkit(object, getNewKey);\n    }\n  }\n}\n","import { mapValues as mapValuesToolkit } from '../../object/mapValues.ts';\nimport { identity } from '../_internal/identity.ts';\nimport { property } from './property.ts';\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined\n): Record<K, V>;\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V>;\n\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue?: PropertyKey | readonly PropertyKey[] | null | undefined | ((value: T[K], key: K, object: T) => V)\n): Record<K, V> {\n  getNewValue = getNewValue ?? (identity as (value: T[K], key: K, object: T) => V);\n\n  switch (typeof getNewValue) {\n    case 'string':\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      return mapValuesToolkit(object, property(getNewValue));\n    }\n    case 'function': {\n      return mapValuesToolkit(object, getNewValue);\n    }\n  }\n}\n","/**\n * Finds the element in an array that has the maximum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @returns {T | undefined} The element with the maximum value.\n * @example\n * // Returns 9\n * max([3, 1, 4, 1, 5, 9])\n *\n * @example\n * // Returns 8\n * max([0, -3, 2, 8, 7])\n */\nexport function max<T>(items: readonly [T, ...T[]]): T;\nexport function max(): undefined;\nexport function max<T>(items?: readonly T[]): T | undefined;\nexport function max<T>(items: readonly T[] = []): T | undefined {\n  let maxElement = items[0];\n  let max = undefined;\n\n  for (const element of items) {\n    if (max == null || element > max) {\n      max = element;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n */\nexport function maxBy<T>(items: T[], getValue: (element: T) => number): T {\n  let maxElement = items[0];\n  let max = -Infinity;\n\n  for (const element of items) {\n    const value = getValue(element);\n    if (value > max) {\n      max = value;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","import { mean } from './mean.ts';\n\n/**\n * Calculates the average of an array of numbers when applying\n * the `getValue` function to each element.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\n *\n * @example\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\n * meanBy([], x => x.a); // Returns: NaN\n */\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return mean(nums);\n}\n","/**\n * Creates a memoized version of the provided function. The memoized function caches\n * results based on the argument it receives, so if the same argument is passed again,\n * it returns the cached result instead of recomputing it.\n *\n * This function works with functions that take zero or just one argument. If your function\n * originally takes multiple arguments, you should refactor it to take a single object or array\n * that combines those arguments.\n *\n * If the argument is not primitive (e.g., arrays or objects), provide a\n * `getCacheKey` function to generate a unique cache key for proper caching.\n *\n * @param {F} fn - The function to be memoized. It should accept a single argument and return a value.\n * @param {MemoizeOptions<Parameters<F>[0], ReturnType<F>>} [options={}] - Optional configuration for the memoization.\n * @param {MemoizeCache<any, V>} [options.cache] - The cache object used to store results. Defaults to a new `Map`.\n * @param {(args: A) => unknown} [options.getCacheKey] - An optional function to generate a unique cache key for each argument.\n *\n * @returns {F & { cache: MemoizeCache<any, ReturnType<F>> }} - The memoized function with an additional `cache` property that exposes the internal cache.\n *\n * @example\n * // Example using the default cache\n * const add = (x: number) => x + 10;\n * const memoizedAdd = memoize(add);\n *\n * console.log(memoizedAdd(5)); // 15\n * console.log(memoizedAdd(5)); // 15 (cached result)\n * console.log(memoizedAdd.cache.size); // 1\n *\n * @example\n * // Example using a custom resolver\n * const sum = (arr: number[]) => arr.reduce((x, y) => x + y, 0);\n * const memoizedSum = memoize(sum, { getCacheKey: (arr: number[]) => arr.join(',') });\n * console.log(memoizedSum([1, 2])); // 3\n * console.log(memoizedSum([1, 2])); // 3 (cached result)\n * console.log(memoizedSum.cache.size); // 1\n *\n * @example\n * // Example using a custom cache implementation\n * class CustomCache<K, T> implements MemoizeCache<K, T> {\n *   private cache = new Map<K, T>();\n *\n *   set(key: K, value: T): void {\n *     this.cache.set(key, value);\n *   }\n *\n *   get(key: K): T | undefined {\n *     return this.cache.get(key);\n *   }\n *\n *   has(key: K): boolean {\n *     return this.cache.has(key);\n *   }\n *\n *   delete(key: K): boolean {\n *     return this.cache.delete(key);\n *   }\n *\n *   clear(): void {\n *     this.cache.clear();\n *   }\n *\n *   get size(): number {\n *     return this.cache.size;\n *   }\n * }\n * const customCache = new CustomCache<string, number>();\n * const memoizedSumWithCustomCache = memoize(sum, { cache: customCache });\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3\n * console.log(memoizedSumWithCustomCache([1, 2])); // 3 (cached result)\n * console.log(memoizedAddWithCustomCache.cache.size); // 1\n */\nexport function memoize<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    cache?: MemoizeCache<any, ReturnType<F>>;\n    getCacheKey?: (args: Parameters<F>[0]) => unknown;\n  } = {}\n): F & { cache: MemoizeCache<any, ReturnType<F>> } {\n  const { cache = new Map<unknown, ReturnType<F>>(), getCacheKey } = options;\n\n  const memoizedFn = function (this: unknown, arg: Parameters<F>[0]): ReturnType<F> {\n    const key = getCacheKey ? getCacheKey(arg) : arg;\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = fn.call(this, arg);\n\n    cache.set(key, result);\n\n    return result;\n  };\n\n  memoizedFn.cache = cache;\n\n  return memoizedFn as F & { cache: MemoizeCache<any, ReturnType<F>> };\n}\n\nexport interface MemoizeCache<K, V> {\n  set(key: K, value: V): void;\n  get(key: K): V | undefined;\n  has(key: K): boolean;\n  delete(key: K): boolean | void;\n  clear(): void;\n  size: number;\n}\n","import { noop } from '../../function/noop.ts';\nimport { mergeWith } from './mergeWith.ts';\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The first source object whose properties will be merged into the target object.\n * @returns {O & S} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S - Type of the first source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S>(object: O, source: S): O & S;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object to be merged into the target object.\n * @param {S2} source2 - The second source object to be merged into the target object.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n * @template S4 - Type of the fourth source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} any - The target object into which the source object properties will be merged. This object is modified in place.\n * @param object\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge(object: any, ...sources: any[]): any;\n\nexport function merge(object: any, ...sources: any[]): any {\n  return mergeWith(object, ...sources, noop);\n}\n","/**\n * Finds the element in an array that has the minimum value.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @returns {T | undefined} The element with the minimum value.\n * @example\n * // Returns 1\n * min([3, 1, 4, 1, 5, 9])\n *\n * @example\n * // Returns -3\n * min([0, -3, 2, 8, 7])\n */\nexport function min<T>(items: readonly [T, ...T[]]): T;\nexport function min(): undefined;\nexport function min<T>(items?: readonly T[]): T | undefined;\nexport function min<T>(items: readonly T[] = []): T {\n  let minElement = items[0];\n  let min = undefined;\n\n  for (const element of items) {\n    if (min == null || element < min) {\n      min = element;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n */\nexport function minBy<T>(items: T[], getValue: (element: T) => number): T {\n  let minElement = items[0];\n  let min = Infinity;\n\n  for (const element of items) {\n    const value = getValue(element);\n    if (value < min) {\n      min = value;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template F - The type of the function to negate.\n * @param {F} func - The function to negate.\n * @returns {F} The new negated function, which negates the boolean result of `func`.\n */\nexport function negate<F extends (...args: unknown[]) => boolean>(func: F): F {\n  return ((...args: any[]) => !func(...args)) as F;\n}\n","/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to omit keys from.\n * @param {K[]} keys - An array of keys to be omitted from the object.\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = omit(obj, ['b', 'c']);\n * // result will be { a: 1 }\n */\nexport function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n\n  for (const key of keys) {\n    delete result[key];\n  }\n\n  return result as Omit<T, K>;\n}\n","/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns false.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit properties from.\n * @param {(value: T[string], key: keyof T) => boolean} shouldOmit - A predicate function that determines\n * whether a property should be omitted. It takes the property's key and value as arguments and returns `true`\n * if the property should be omitted, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that do not satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'omit', c: 3 };\n * const shouldOmit = (key, value) => typeof value === 'string';\n * const result = omitBy(obj, shouldOmit);\n * // result will be { a: 1, c: 3 }\n */\nexport function omitBy<T extends Record<string, any>>(\n  obj: T,\n  shouldOmit: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (shouldOmit(value, key)) {\n      continue;\n    }\n\n    (result as any)[key] = value;\n  }\n\n  return result;\n}\n","/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F} func - The function to restrict.\n * @returns {F} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends () => any>(func: F): F {\n  let called = false;\n  let cache: ReturnType<F> | undefined;\n\n  return function () {\n    if (called) {\n      return cache;\n    }\n\n    const result = func();\n\n    called = true;\n    cache = result;\n\n    return result;\n  } as F;\n}\n","import { getPath } from '../_internal/getPath';\n\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of keys to sort by, and an array of order directions.\n * It returns the sorted array, ordering by each key according to its corresponding direction\n * ('asc' for ascending or 'desc' for descending). If values for a key are equal,string\n * it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {T[] | null} collection - The array of objects to be sorted.\n * @param {string | Array<string | string[]>} keys - An array of keys (property names or property paths) to sort by.\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\n * @returns {T[]} - The sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = orderBy(users, ['user', 'age'], ['asc', 'desc']);\n * // result will be:\n * // [\n * //   { user: 'barney', age: 36 },\n * //   { user: 'barney', age: 34 },\n * //   { user: 'fred', age: 48 },\n * //   { user: 'fred', age: 40 },\n * // ]\n */\nexport function orderBy<T extends object>(\n  collection?: T[] | null,\n  keys?: string | Array<string | string[]>,\n  orders?: unknown | unknown[]\n): T[] {\n  if (collection == null) {\n    return [];\n  }\n\n  if (!Array.isArray(keys)) {\n    keys = keys == null ? [] : [keys];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n\n  const compareValues = <V>(a: V, b: V, order: string) => {\n    if (a < b) {\n      return order === 'desc' ? 1 : -1; // Default is ascending order\n    }\n\n    if (a > b) {\n      return order === 'desc' ? -1 : 1;\n    }\n\n    return 0;\n  };\n\n  const getValueByPath = (key: string | string[], obj: T) => {\n    if (Array.isArray(key)) {\n      let value: object = obj;\n\n      for (let i = 0; i < key.length; i++) {\n        value = value[key[i] as keyof typeof value];\n      }\n\n      return value;\n    }\n\n    return obj[key as keyof typeof obj];\n  };\n\n  keys = keys.map(key => getPath(key, collection[0]));\n\n  const shallowCopiedCollection = collection.slice();\n  const orderedCollection = shallowCopiedCollection.sort((a, b) => {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      const valueA = getValueByPath(key, a);\n      const valueB = getValueByPath(key, b);\n      const order = String((orders as unknown[])[i]); // For Object('desc') case\n\n      const comparedResult = compareValues(valueA, valueB, order);\n\n      if (comparedResult !== 0) {\n        return comparedResult;\n      }\n    }\n\n    return 0;\n  });\n\n  return orderedCollection;\n}\n","import { isKey } from './isKey';\nimport { toPath } from './toPath';\n\n/**\n * Get the `path` (property name) from the `key` (property name or property path).\n *\n * @param {string | string[]} key - The `key` (property name or property path) to convert.\n * @param {object} object - The object to query.\n * @returns {string | string[]} The converted key (only property name).\n */\nexport function getPath(key: string | string[], object: object): string | string[] {\n  if (Array.isArray(key)) {\n    const path = [];\n\n    for (let i = 0; i < key.length; i++) {\n      const k = key[i];\n\n      if (isKey(k, object)) {\n        object = object[k as keyof typeof object];\n        path.push(k);\n      } else {\n        const keys = toPath(k);\n\n        for (let i = 0; i < keys.length; i++) {\n          object = object[keys[i] as keyof typeof object];\n          path.push(keys[i]);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  return isKey(key, object) ? key : toPath(key);\n}\n","/**\n * Pads the end of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padEnd('abc', 6);          // result will be 'abc   '\n * const result2 = padEnd('abc', 6, '_-');    // result will be 'abc_-_'\n * const result3 = padEnd('abc', 3);          // result will be 'abc'\n * const result4 = padEnd('abc', 2);          // result will be 'abc'\n */\n\nexport function padEnd(str: string, length = 0, chars = ' '): string {\n  return str.padEnd(length, chars);\n}\n","/**\n * Pads the start of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padStart('abc', 6);          // result will be '   abc'\n * const result2 = padStart('abc', 6, '_-');    // result will be '_-_abc'\n * const result3 = padStart('abc', 3);          // result will be 'abc'\n * const result4 = padStart('abc', 2);          // result will be 'abc'\n */\nexport function padStart(str: string, length = 0, chars = ' '): string {\n  return str.padStart(length, chars);\n}\n","/**\n * Splits an array into two groups based on a predicate function.\n *\n * This function takes an array and a predicate function. It returns a tuple of two arrays:\n * the first array contains elements for which the predicate function returns true, and\n * the second array contains elements for which the predicate function returns false.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to partition.\n * @param {(value: T) => boolean} isInTruthy - A predicate function that determines\n * whether an element should be placed in the truthy array. The function is called with each\n * element of the array.\n * @returns {[T[], T[]]} A tuple containing two arrays: the first array contains elements for\n * which the predicate returned true, and the second array contains elements for which the\n * predicate returned false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const isEven = x => x % 2 === 0;\n * const [even, odd] = partition(array, isEven);\n * // even will be [2, 4], and odd will be [1, 3, 5]\n */\nexport function partition<T>(arr: readonly T[], isInTruthy: (value: T) => boolean): [truthy: T[], falsy: T[]] {\n  const truthy: T[] = [];\n  const falsy: T[] = [];\n\n  for (const item of arr) {\n    if (isInTruthy(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item);\n    }\n  }\n\n  return [truthy, falsy];\n}\n","import { getWords } from './_internal/getWords.ts';\nimport { capitalize } from './capitalize.ts';\n\n/**\n * Converts a string to Pascal case.\n *\n * Pascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.\n *\n * @param {string} str - The string that is to be changed to pascal case.\n * @returns {string} - The converted string to Pascal case.\n *\n * @example\n * const convertedStr1 = pascalCase('pascalCase') // returns 'PascalCase'\n * const convertedStr2 = pascalCase('some whitespace') // returns 'SomeWhitespace'\n * const convertedStr3 = pascalCase('hyphen-text') // returns 'HyphenText'\n * const convertedStr4 = pascalCase('HTTPRequest') // returns 'HttpRequest'\n */\nexport const pascalCase = (str: string): string => {\n  const words = getWords(str);\n  return words.map(word => capitalize(word)).join('');\n};\n","/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to pick keys from.\n * @param {K[]} keys - An array of keys to be picked from the object.\n * @returns {Pick<T, K>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n */\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n\n  for (const key of keys) {\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n","/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns true.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to pick properties from.\n * @param {(value: T[keyof T], key: keyof T) => boolean} shouldPick - A predicate function that determines\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\n * if the property should be picked, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'pick', c: 3 };\n * const shouldPick = (value) => typeof value === 'string';\n * const result = pickBy(obj, shouldPick);\n * // result will be { b: 'pick' }\n */\nexport function pickBy<T extends Record<string, any>>(\n  obj: T,\n  shouldPick: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (!shouldPick(value, key)) {\n      continue;\n    }\n\n    (result as any)[key] = value;\n  }\n\n  return result;\n}\n","/**\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\n *\n * If `step` is not provided, it defaults to `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} [end] - The end number of the range (exclusive).\n * @param {number} [step] - The step value for the range. (default: 1)\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n *\n * @example\n * // Throws an error: The step value must be a non-zero integer.\n * range(1, 4, 0);\n */\nexport function range(end: number): number[];\nexport function range(start: number, end: number): number[];\nexport function range(start: number, end: number, step: number): number[];\nexport function range(start: number, end?: number, step?: number): number[] {\n  if (end == null) {\n    end = start;\n    start = 0;\n  }\n\n  if (step == null) {\n    step = 1;\n  }\n\n  if (!Number.isInteger(step) || step === 0) {\n    throw new Error(`The step value must be a non-zero integer.`);\n  }\n\n  const length = Math.max(Math.ceil((end - start) / step), 0);\n  const result = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    result[i] = start + i * step;\n  }\n\n  return result;\n}\n","import { rest as restToolkit } from '../../function/rest.ts';\n\n/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest<F extends (...args: any[]) => any>(\n  func: F,\n  start = func.length - 1\n): (...args: any[]) => ReturnType<F> {\n  start = Number.parseInt(start as any, 10);\n\n  if (Number.isNaN(start) || start < 0) {\n    start = func.length - 1;\n  }\n\n  return restToolkit(func, start);\n}\n","/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest<F extends (...args: any[]) => any>(\n  func: F,\n  startIndex = func.length - 1\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: any[]) {\n    const rest = args.slice(startIndex);\n    const params = args.slice(0, startIndex);\n    while (params.length < startIndex) {\n      params.push(undefined);\n    }\n    return func.apply(this, [...params, rest]);\n  };\n}\n","/**\n * Rounds a number to a specified precision.\n *\n * This function takes a number and an optional precision value, and returns the number rounded\n * to the specified number of decimal places.\n *\n * @param {number} value - The number to round.\n * @param {number} [precision=0] - The number of decimal places to round to. Defaults to 0.\n * @returns {number} The rounded number.\n * @throws {Error} Throws an error if `Precision` is not integer.\n *\n * @example\n * const result1 = round(1.2345); // result1 will be 1\n * const result2 = round(1.2345, 2); // result2 will be 1.23\n * const result3 = round(1.2345, 3); // result3 will be 1.235\n * const result4 = round(1.2345, 3.1); // This will throw an error\n */\nexport function round(value: number, precision = 0): number {\n  if (!Number.isInteger(precision)) {\n    throw new Error('Precision must be an integer.');\n  }\n  const multiplier = Math.pow(10, precision);\n  return Math.round(value * multiplier) / multiplier;\n}\n","/**\n * Returns a random element from an array.\n *\n * This function takes an array and returns a single element selected randomly from the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to sample from.\n * @returns {T} A random element from the array.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const randomElement = sample(array);\n * // randomElement will be one of the elements from the array, selected randomly.\n */\nexport function sample<T>(arr: readonly T[]): T {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n","import { randomInt } from '../math/randomInt.ts';\n\n/**\n * Returns a sample element array of a specified `size`.\n *\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\n *\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algoritm}\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to sample from.\n * @param {number} size - The size of sample.\n * @returns {T[]} A new array with sample size applied.\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\n *\n * @example\n * const result = sampleSize([1, 2, 3], 2)\n * // result will be an array containing two of the elements from the array.\n * // [1, 2] or [1, 3] or [2, 3]\n */\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\n  if (size > array.length) {\n    throw new Error('Size must be less than or equal to the length of array.');\n  }\n\n  const result = new Array(size);\n  const selected = new Set();\n\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\n    let index = randomInt(0, step + 1);\n\n    if (selected.has(index)) {\n      index = step;\n    }\n\n    selected.add(index);\n\n    result[resultIndex] = array[index];\n  }\n\n  return result;\n}\n","/**\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\n *\n * This function takes an array and returns a new array with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to shuffle.\n * @returns {T[]} A new array with its elements shuffled in random order.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const shuffledArray = shuffle(array);\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\n */\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = arr.slice();\n\n  /**\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n   */\n  for (let i = result.length - 1; i >= 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n\n  return result;\n}\n","import { isNil } from '../../predicate/isNil.ts';\n\n/**\n * Returns the length of an array, string, or object.\n *\n * This function takes an array, string, or object and returns its length.\n * For arrays and strings, it returns the number of elements or characters, respectively.\n * For objects, it returns the number of enumerable properties.\n *\n * @template T - The type of the input value.\n * @param {T[] | object | string | Map<unknown, T> | Set<T> | null | undefined } target - The value whose size is to be determined. It can be an array, string, or object.\n * @returns {number} The size of the input value.\n *\n * @example\n * const arr = [1, 2, 3];\n * const arrSize = size(arr);\n * // arrSize will be 3\n *\n * const str = 'hello';\n * const strSize = size(str);\n * // strSize will be 5\n *\n * const obj = { a: 1, b: 2, c: 3 };\n * const objSize = size(obj);\n * // objSize will be 3\n *\n * const emptyArr = [];\n * const emptyArrSize = size(emptyArr);\n * // emptyArrSize will be 0\n *\n * const emptyStr = '';\n * const emptyStrSize = size(emptyStr);\n * // emptyStrSize will be 0\n *\n * const emptyObj = {};\n * const emptyObjSize = size(emptyObj);\n * // emptyObjSize will be 0\n */\nexport function size<T>(target: T[] | object | string | Map<unknown, T> | Set<T> | null | undefined): number {\n  if (isNil(target)) {\n    return 0;\n  }\n\n  if (target instanceof Map || target instanceof Set) {\n    return target.size;\n  }\n\n  return Object.keys(target).length;\n}\n","import { getWords } from './_internal/getWords.ts';\n\n/**\n * Converts a string to snake case.\n *\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string} str - The string that is to be changed to snake case.\n * @returns {string} - The converted string to snake case.\n *\n * @example\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\n */\n\nexport const snakeCase = (str: string): string => {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('_');\n};\n","import { compareValues } from '../_internal/compareValues';\n\n/**\n * Sorts an array of objects based on the given `criteria`.\n *\n * - If you provide keys, it sorts the objects by the values of those keys.\n * - If you provide functions, it sorts based on the values returned by those functions.\n *\n * The function returns the array of objects sorted in ascending order.\n * If two objects have the same value for the current criterion, it uses the next criterion to determine their order.\n *\n * @template T - The type of the objects in the array.\n * @param {T[]} arr - The array of objects to be sorted.\n * @param {Array<((item: T) => unknown) | keyof T>} criteria - The criteria for sorting. This can be an array of object keys or functions that return values used for sorting.\n * @returns {T[]} - The sorted array.\n *\n * @example\n * const users = [\n *  { user: 'foo', age: 24 },\n *  { user: 'bar', age: 7 },\n *  { user: 'foo ', age: 8 },\n *  { user: 'bar ', age: 29 },\n * ];\n *\n * sortBy(users, ['user', 'age']);\n * sortBy(users, [obj => obj.user, 'age']);\n * // results will be:\n * // [\n * //   { user : 'bar', age: 7 },\n * //   { user : 'bar', age: 29 },\n * //   { user : 'foo', age: 8 },\n * //   { user : 'foo', age: 24 },\n * // ]\n */\nexport function sortBy<T extends object>(arr: T[], criteria: Array<((item: T) => unknown) | keyof T>): T[] {\n  return arr.slice().sort((a, b) => {\n    for (let i = 0; i < criteria.length; i++) {\n      const iteratee = criteria[i];\n      const iterateeIsFunction = typeof iteratee === 'function';\n\n      const valueA = iterateeIsFunction ? iteratee(a) : a[iteratee];\n      const valueB = iterateeIsFunction ? iteratee(b) : b[iteratee];\n\n      const result = compareValues(valueA, valueB, 'asc');\n\n      if (result !== 0) {\n        return result;\n      }\n    }\n\n    return 0;\n  });\n}\n","import { getWords } from './_internal/getWords.ts';\n\n/**\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\n *\n * Start case is the naming convention in which each word is written with an initial capital letter.\n * @param {string} str - The string to convert.\n * @returns {string} The converted string.\n *\n * @example\n * const result1 = startCase('hello world');  // result will be 'Hello World'\n * const result2 = startCase('HELLO WORLD');  // result will be 'Hello World'\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\n */\nexport function startCase(str: string): string {\n  const words = getWords(str.trim());\n  let result = '';\n  for (const word of words) {\n    if (result) {\n      result += ' ';\n    }\n    if (word === word.toUpperCase()) {\n      result += word;\n    } else {\n      result += word[0].toUpperCase() + word.slice(1).toLowerCase();\n    }\n  }\n  return result;\n}\n","/**\n * Checks if a string contains another string at the beginning of the string.\n *\n * Checks if one string startsWith another string. Optional position parameter to start searching from a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional offset to start searching in the str string\n * @returns {boolean} - True if the str string starts with the target string.\n *\n * @example\n * const isPrefix = startsWith('fooBar', 'foo') // returns true\n * const isPrefix = startsWith('fooBar', 'bar') // returns false\n * const isPrefix = startsWith('fooBar', 'abc') // returns false\n * const isPrefix = startsWith('fooBar', 'Bar', 2) // returns true\n * const isPrefix = startsWith('fooBar', 'Bar', 5) // returns false\n */\nexport const startsWith = (str: string, target: string, position = 0): boolean => {\n  return str.startsWith(target, position);\n};\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the sum of an array of numbers when applying\n * the `getValue` function to each element.\n *\n * If the array is empty, this function returns `0`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\n *\n * @example\n * sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 6\n * sumBy([], x => x.a); // Returns: 0\n */\nexport function sumBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return sum(nums);\n}\n","/**\n * Returns an empty array when the input is a single-element array.\n *\n * @template T - The type of the single element in the array.\n * @param {[T]} arr - The single-element array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [1];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input is an empty array.\n *\n * @template T - The type of elements in the array.\n * @param {[]} arr - The empty array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail(arr: readonly []): [];\n\n/**\n * Returns a new array with all elements except for the first when the input is a tuple array.\n *\n * @template T - The type of the first element in the tuple array.\n * @template U - The type of the remaining elements in the tuple array.\n * @param {[T, ...U[]]} arr - The tuple array to process.\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr = [1, 2, 3];\n * const result = tail(arr);\n * // result will be [2, 3]\n */\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[];\n\nexport function tail<T>(arr: readonly T[]): T[] {\n  const len = arr.length;\n  if (len <= 1) {\n    return [];\n  }\n  const result = new Array(len - 1);\n  for (let i = 1; i < len; i++) {\n    result[i - 1] = arr[i];\n  }\n  return result;\n}\n","/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {number} count - The number of elements to take.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: readonly T[], count: number): T[] {\n  return arr.slice(0, count);\n}\n","/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: readonly T[], count = 1): T[] {\n  if (count <= 0) {\n    return [];\n  }\n\n  return arr.slice(-count);\n}\n","/**\n * Takes elements from the end of the array while the predicate function returns `true`.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {function(T): boolean} shouldContinueTaking - The function invoked per element.\n * @returns {T[]} A new array containing the elements taken from the end while the predicate returns `true`.\n *\n * @example\n * // Returns [3, 2, 1]\n * takeRightWhile([5, 4, 3, 2, 1], n => n < 4);\n *\n * @example\n * // Returns []\n * takeRightWhile([1, 2, 3], n => n > 3);\n */\nexport function takeRightWhile<T>(arr: readonly T[], shouldContinueTaking: (item: T) => boolean): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!shouldContinueTaking(arr[i])) {\n      return arr.slice(i + 1);\n    }\n  }\n\n  return arr.slice();\n}\n","/**\n * Returns a new array containing the leading elements of the provided array\n * that satisfy the provided predicate function. It stops taking elements as soon\n * as an element does not satisfy the predicate.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(element: T) => boolean} shouldContinueTaking - The predicate function that is called with each element. Elements are included in the result as long as this function returns true.\n * @returns {T[]} A new array containing the leading elements that satisfy the predicate.\n *\n * @example\n * // Returns [1, 2]\n * takeWhile([1, 2, 3, 4], x => x < 3);\n *\n * @example\n * // Returns []\n * takeWhile([1, 2, 3, 4], x => x > 3);\n */\nexport function takeWhile<T>(arr: readonly T[], shouldContinueTaking: (element: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (const item of arr) {\n    if (!shouldContinueTaking(item)) {\n      break;\n    }\n\n    result.push(item);\n  }\n\n  return result;\n}\n","/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @returns {F} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<F extends (...args: any[]) => void>(func: F, throttleMs: number): F {\n  let lastCallTime: number | null;\n\n  const throttledFunction = function (...args: Parameters<F>) {\n    const now = Date.now();\n\n    if (lastCallTime == null || now - lastCallTime >= throttleMs) {\n      lastCallTime = now;\n      func(...args);\n    }\n  } as F;\n\n  return throttledFunction;\n}\n","/**\n * Creates a new array filled with the specified value from the start position up to, but not including, the end position.\n * This function does not mutate the original array.\n *\n * @template T - The type of elements in the original array.\n * @template U - The type of the value to fill the new array with.\n * @param {Array<T>} arr - The array to base the new array on.\n * @param {U} value - The value to fill the new array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The new array with the filled values.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * let result = toFilled(array, '*', 2);\n * console.log(result); // [1, 2, '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', 1, 4);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*');\n * console.log(result); // ['*', '*', '*', '*', '*']\n * console.log(array); // [1, 2, 3, 4, 5]\n *\n * result = toFilled(array, '*', -4, -1);\n * console.log(result); // [1, '*', '*', '*', 5]\n * console.log(array); // [1, 2, 3, 4, 5]\n */\n\nexport function toFilled<T, U>(arr: readonly T[], value: U): Array<T | U>;\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number): Array<T | U>;\nexport function toFilled<T, U>(arr: readonly T[], value: U, start: number, end: number): Array<T | U>;\nexport function toFilled<T, U>(arr: readonly T[], value: U, start = 0, end = arr.length): Array<T | U> {\n  const length = arr.length;\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\n\n  const newArr: Array<T | U> = arr.slice();\n\n  for (let i = finalStart; i < finalEnd; i++) {\n    newArr[i] = value;\n  }\n\n  return newArr;\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { merge } from './merge.ts';\n\n/**\n * Merges the properties of the source object into a deep clone of the target object.\n * Unlike `merge`, This function does not modify the original target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n *\n * - If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * - If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function does not mutate the target object.\n *\n * @param {T} target - The target object to be cloned and merged into. This object is not modified directly.\n * @param {S} source - The source object whose properties will be merged into the cloned target object.\n * @returns {T & S} A new object with properties from the source object merged into a deep clone of the target object.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = toMerged(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function toMerged<T, S>(target: T, source: S): T & S;\nexport function toMerged(target: any, source: any) {\n  return merge(cloneDeep(target), source);\n}\n","import { ary } from './ary.ts';\n\n/**\n * Creates a function that accepts up to one argument, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n */\nexport function unary<F extends (...args: any[]) => any>(func: F): (...args: any[]) => ReturnType<F> {\n  return ary(func, 1);\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the mapper function.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr - The array to process.\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\n *\n * @example\n * ```ts\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (const item of arr) {\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {Array<[...T]>} zipped - The nested array to unzip.\n * @returns {Unzip<T>} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T extends unknown[]>(zipped: Array<[...T]>): Unzip<T> {\n  // For performance reasons, use this implementation instead of\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\n  let maxLen = 0;\n\n  for (let i = 0; i < zipped.length; i++) {\n    if (zipped[i].length > maxLen) {\n      maxLen = zipped[i].length;\n    }\n  }\n\n  const result = new Array(maxLen) as Unzip<T>;\n\n  for (let i = 0; i < maxLen; i++) {\n    result[i] = new Array(zipped.length);\n    for (let j = 0; j < zipped.length; j++) {\n      result[i][j] = zipped[j][i];\n    }\n  }\n\n  return result;\n}\n\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\n","/**\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\n *\n * @template T, R\n * @param {T[][]} target - The nested array to unzip. This is an array of arrays,\n * where each inner array contains elements to be unzipped.\n * @param {(...args: T[]) => R} iteratee - A function to transform the unzipped elements.\n * @returns {R[]} A new array of unzipped and transformed elements.\n *\n * @example\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\n * const result = unzipWith(nestedArray, (item, item2, item3) => item + item2 + item3);\n * // result will be [9, 12]\n */\nexport function unzipWith<T, R>(target: readonly T[][], iteratee: (...args: T[]) => R): R[] {\n  const maxLength = Math.max(...target.map(innerArray => innerArray.length));\n  const result: R[] = new Array(maxLength);\n\n  for (let i = 0; i < maxLength; i++) {\n    const group = new Array(target.length);\n\n    for (let j = 0; j < target.length; j++) {\n      group[j] = target[j][i];\n    }\n\n    result[i] = iteratee(...group);\n  }\n\n  return result;\n}\n","import { timeout } from './timeout.ts';\n\n/**\n * Executes an async function and enforces a timeout.\n *\n * If the promise does not resolve within the specified time,\n * the timeout will trigger and the returned promise will be rejected.\n *\n *\n * @template T\n * @param {() => Promise<T>} run - A function that returns a promise to be executed.\n * @param {number} ms - The timeout duration in milliseconds.\n * @returns {Promise<T>} A promise that resolves with the result of the `run` function or rejects if the timeout is reached.\n *\n * @example\n * try {\n *   await withTimeout(() => {}, 1000); // Timeout exception after 1 second\n * } catch (error) {\n *   console.error(error); // Will log 'TimeoutError'\n * }\n */\nexport async function withTimeout<T>(run: () => Promise<T>, ms: number): Promise<T> {\n  return Promise.race([run(), timeout(ms) as T]);\n}\n","/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {T[]} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\n  const valuesSet = new Set(values);\n  return array.filter(item => !valuesSet.has(item));\n}\n","import { difference } from './difference.ts';\nimport { intersection } from './intersection.ts';\nimport { union } from './union.ts';\n\n/**\n * Computes the symmetric difference between two arrays. The symmetric difference is the set of elements\n * which are in either of the arrays, but not in their intersection.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both.\n *\n * @example\n * // Returns [1, 2, 5, 6]\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\n *\n * @example\n * // Returns ['a', 'c']\n * xor(['a', 'b'], ['b', 'c']);\n */\nexport function xor<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return difference(union(arr1, arr2), intersection(arr1, arr2));\n}\n","import { differenceBy } from './differenceBy.ts';\nimport { intersectionBy } from './intersectionBy.ts';\nimport { unionBy } from './unionBy.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom mapping function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection, determined by the result of the mapping function.\n *\n * @template T - Type of elements in the input arrays.\n * @template U - Type of the values returned by the mapping function.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = obj => obj.id;\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  const union = unionBy(arr1, arr2, mapper);\n  const intersection = intersectionBy(arr1, arr2, mapper);\n\n  return differenceBy(union, intersection, mapper);\n}\n","import { differenceWith } from './differenceWith.ts';\nimport { intersectionWith } from './intersectionWith.ts';\nimport { unionWith } from './unionWith.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom equality function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection.\n *\n * @template T - Type of elements in the input arrays.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\n *\n * @example\n * // Custom equality function for objects with an 'id' property\n * const areObjectsEqual = (a, b) => a.id === b.id;\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areElementsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  const union = unionWith(arr1, arr2, areElementsEqual);\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\n\n  return differenceWith(union, intersection, areElementsEqual);\n}\n","/**\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\n *\n * This function takes two arrays: one containing property names and another containing corresponding values.\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\n * have `undefined` as their values.\n *\n * @template P - The type of elements in the array.\n * @template V - The type of elements in the array.\n * @param {P[]} keys - An array of property names.\n * @param {V[]} values - An array of values corresponding to the property names.\n * @returns {{ [K in P]: V }} A new object composed of the given property names and values.\n *\n * @example\n * const keys = ['a', 'b', 'c'];\n * const values = [1, 2, 3];\n * const result = zipObject(keys, values);\n * // result will be { a: 1, b: 2, c: 3 }\n *\n * const keys2 = ['a', 'b', 'c'];\n * const values2 = [1, 2];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2, c: undefined }\n *\n * const keys2 = ['a', 'b'];\n * const values2 = [1, 2, 3];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2 }\n */\nexport function zipObject<P extends PropertyKey, V>(keys: P[], values: V[]): { [K in P]: V } {\n  const result = {} as { [K in P]: V };\n\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i];\n  }\n\n  return result;\n}\n","import { zip } from '../../array/zip.ts';\nimport { set } from '../object/set.ts';\n\n/**\n * Creates a deeply nested object given arrays of paths and values.\n *\n * This function takes two arrays: one containing arrays of property paths, and the other containing corresponding values.\n * It returns a new object where paths from the first array are used as key paths to set values, with corresponding elements from the second array as values.\n * Paths can be dot-separated strings or arrays of property names.\n *\n * If the `keys` array is longer than the `values` array, the remaining keys will have `undefined` as their values.\n *\n * @template V - The type of elements in the array.\n * @param {P[] | P[][]} keys - An array of property paths, each path can be a dot-separated string or an array of property names.\n * @param {V[]} values - An array of values corresponding to the property paths.\n * @returns {object} A new object composed of the given property paths and values.\n *\n * @example\n * const paths = ['a.b.c', 'd.e.f'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = [['a', 'b', 'c'], ['d', 'e', 'f']];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = ['a.b[0].c', 'a.b[1].d'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n */\nexport function zipObjectDeep<P extends PropertyKey, V>(keys: P[] | P[][], values: V[]): { [K in P]: V } {\n  const result = {} as { [K in P]: V };\n  const zipped = zip<P | P[], V>(keys, values);\n\n  for (let i = 0; i < zipped.length; i++) {\n    const [key, value] = zipped[i];\n\n    if (key != null) {\n      set(result, key, value);\n    }\n  }\n\n  return result;\n}\n","/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes multiple arrays and a combiner function, and returns a new array where each element\n * is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array (optional).\n * @template V - The type of elements in the third array (optional).\n * @template W - The type of elements in the fourth array (optional).\n * @template R - The type of elements in the resulting array.\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} [arr2] - The second array to zip (optional).\n * @param {V[]} [arr3] - The third array to zip (optional).\n * @param {W[]} [arr4] - The fourth array to zip (optional).\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * // Example usage with two arrays:\n * const arr1 = [1, 2, 3];\n * const arr2 = [4, 5, 6];\n * const result = zipWith(arr1, arr2, (a, b) => a + b);\n * // result will be [5, 7, 9]\n *\n * @example\n * // Example usage with three arrays:\n * const arr1 = [1, 2];\n * const arr2 = [3, 4];\n * const arr3 = [5, 6];\n * const result = zipWith(arr1, arr2, arr3, (a, b, c) => `${a}${b}${c}`);\n * // result will be [`135`, `246`]\n */\nexport function zipWith<T, R>(arr1: readonly T[], combine: (item: T) => R): R[];\nexport function zipWith<T, U, R>(arr1: readonly T[], arr2: readonly U[], combine: (item1: T, item2: U) => R): R[];\nexport function zipWith<T, U, V, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  combine: (item1: T, item2: U, item3: V) => R\n): R[];\nexport function zipWith<T, U, V, W, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[],\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\n): R[];\nexport function zipWith<T, R>(arr1: readonly T[], ...rest: any[]): R[] {\n  const arrs = [arr1, ...rest.slice(0, -1)];\n  const combine = rest[rest.length - 1] as (...items: T[]) => R;\n\n  const result: R[] = [];\n  const maxIndex = Math.max(...arrs.map(arr => arr.length));\n\n  for (let i = 0; i < maxIndex; i++) {\n    const elements: T[] = arrs.map(arr => arr[i]);\n    result.push(combine(...elements));\n  }\n\n  return result;\n}\n"],"names":["difference","firstArr","secondArr","secondSet","Set","filter","item","has","differenceBy","mapper","mappedSecondSet","map","differenceWith","areItemsEqual","firstItem","every","secondItem","flatten","arr","depth","result","flooredDepth","Math","floor","recursive","currentDepth","Array","isArray","push","intersection","intersectionBy","intersectionWith","some","compareValues","a","b","order","random","minimum","maximum","Error","randomInt","uniq","from","union","arr1","arr2","concat","unionBy","Map","key","set","values","uniqWith","v","unionWith","zip","arrs","maxIndex","max","x","length","i","element","head","AbortError","constructor","message","super","this","name","TimeoutError","noop","ary","func","n","args","apply","slice","partial","partialArgs","providedArgs","startIndex","arg","placeholder","partialPlaceholder","Symbol","partialRight","placeholderLength","partialRightPlaceholder","rangeLength","providedIndex","sum","nums","mean","clone","obj","isPrimitive","value","Date","getTime","RegExp","source","flags","add","prototype","Object","getPrototypeOf","create","assign","isPlainObject","object","toString","proto","flattenObjectImpl","prefix","keys","prefixedKey","index","mapKeys","getNewKey","mapValues","getNewValue","isTypedArray","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float32Array","Float64Array","cloneDeep","cloneDeepImpl","stack","get","hasOwnProperty","call","input","lastIndex","entries","Buffer","isBuffer","subarray","ArrayBuffer","SharedArrayBuffer","DataView","buffer","copyProperties","File","type","Blob","cause","target","descriptor","getOwnPropertyDescriptor","writable","isObjectLike","merge","sourceKeys","sourceValue","targetValue","undefined","regexpTag","stringTag","numberTag","booleanTag","argumentsTag","symbolTag","dateTag","mapTag","setTag","arrayTag","functionTag","arrayBufferTag","objectTag","errorTag","dataViewTag","uint8ArrayTag","uint8ClampedArrayTag","uint16ArrayTag","uint32ArrayTag","bigUint64ArrayTag","int8ArrayTag","int16ArrayTag","int32ArrayTag","bigInt64ArrayTag","float32ArrayTag","float64ArrayTag","getSymbols","getOwnPropertySymbols","symbol","propertyIsEnumerable","getTag","areObjectsEqual","is","aTag","bTag","valueOf","y","Number","isNaN","aStack","bStack","size","aValues","bValues","aValue","findIndex","bValue","splice","byteLength","byteOffset","aKeys","bKeys","propKey","aProp","delete","isNil","isLength","isSafeInteger","delay","ms","signal","Promise","resolve","reject","abortError","aborted","timeoutId","setTimeout","addEventListener","clearTimeout","once","async","timeout","capitalize","str","charAt","toUpperCase","toLowerCase","CASE_SPLIT_PATTERN","getWords","match","IS_PLAIN","IS_DEEP","isDeepKey","test","isSymbol","toKey","toPath","deepKey","ESCAPE_REGEXP","PROPERTY_REGEXP","exec","expr","quote","substr","replace","path","defaultValue","resolvedPath","current","property","isArrayMatch","countedIndex","sourceItem","targetItem","isMatch","isMapMatch","isSetMatch","matches","cloneDeepToolkit","iterator","IS_UNSIGNED_INTEGER","isIndex","isInteger","MAX_SAFE_INTEGER","isArguments","matchesProperty","Boolean","isConcatSpreadable","regexIsDeepProp","regexIsPlainProp","isKey","hasOwn","nextKey","bind","thisObj","binded","bindPlaceholder","identity","tag","toStringTag","isTypedArrayToolkit","mergeWith","otherArgs","sources","mergeWithDeep","merged","counter","guard","aryToolkit","camelCase","words","first","rest","word","join","chunk","chunkLength","ceil","start","end","chunkToolkit","clamp","bound1","bound2","min","compact","countBy","debounce","debounceMs","debounced","cancel","differenceToolkit","drop","itemsCount","dropRight","dropRightWhile","canContinueDropping","dropWhile","dropEndIndex","position","endsWith","fill","array","finalStart","finalEnd","fillToolkit","find","doesMatch","entry","flatMap","iteratee","flattenDeep","Infinity","flattenDepth","flattenObject","forEachRight","callback","groupBy","getKeyFromItem","inRange","indexOf","searchElement","fromIndex","initial","invert","isArrayLike","isBoolean","isEqual","isFunction","isNotNil","isNull","isString","isSubset","superset","subset","isUndefined","keyBy","last","mapKeysToolkit","mapValuesToolkit","items","maxElement","maxBy","getValue","meanBy","memoize","fn","options","cache","getCacheKey","memoizedFn","minElement","minBy","negate","omit","omitBy","shouldOmit","called","orderBy","collection","orders","getValueByPath","getPath","k","sort","valueA","valueB","String","comparedResult","padEnd","chars","padStart","partition","isInTruthy","truthy","falsy","pick","pickBy","shouldPick","range","step","parseInt","params","restToolkit","round","precision","multiplier","pow","sample","sampleSize","selected","resultIndex","shuffle","j","sortBy","criteria","iterateeIsFunction","startCase","trim","startsWith","sumBy","tail","len","take","count","takeRight","takeRightWhile","shouldContinueTaking","takeWhile","throttle","throttleMs","lastCallTime","now","toFilled","newArr","toMerged","unary","uniqBy","unzip","zipped","maxLen","unzipWith","maxLength","innerArray","group","withTimeout","run","race","without","valuesSet","xor","xorBy","xorWith","areElementsEqual","zipObject","zipObjectDeep","zipWith","combine","elements"],"mappings":"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"}