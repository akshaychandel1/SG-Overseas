'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const before = (n, func) => {
    if (!Number.isInteger(n) || n < 0) {
        throw new Error('n must be a non-negative integer.');
    }
    let counter = 0;
    return ((...args) => {
        if (++counter < n) {
            return func(...args);
        }
        return undefined;
    });
};

const after = (n, func) => {
    if (!Number.isInteger(n) || n < 0) {
        throw new Error(`n must be a non-negative integer.`);
    }
    let counter = 0;
    return ((...args) => {
        if (++counter >= n) {
            return func(...args);
        }
        return undefined;
    });
};

function debounce(func, debounceMs, { signal } = {}) {
    let timeoutId = null;
    const debounced = function (...args) {
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
        }
        if (signal?.aborted) {
            return;
        }
        timeoutId = setTimeout(() => {
            func(...args);
            timeoutId = null;
        }, debounceMs);
    };
    const onAbort = function () {
        debounced.cancel();
    };
    debounced.cancel = function () {
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
    };
    signal?.addEventListener('abort', onAbort, { once: true });
    return debounced;
}

function noop() { }

function once(func) {
    let called = false;
    let cache;
    return function () {
        if (called) {
            return cache;
        }
        const result = func();
        called = true;
        cache = result;
        return result;
    };
}

function throttle(func, throttleMs) {
    let lastCallTime;
    const throttledFunction = function (...args) {
        const now = Date.now();
        if (lastCallTime == null || now - lastCallTime >= throttleMs) {
            lastCallTime = now;
            func(...args);
        }
    };
    return throttledFunction;
}

function negate(func) {
    return ((...args) => !func(...args));
}

function memoize(fn, options = {}) {
    const { cache = new Map(), getCacheKey } = options;
    const memoizedFn = function (arg) {
        const key = getCacheKey ? getCacheKey(arg) : arg;
        if (cache.has(key)) {
            return cache.get(key);
        }
        const result = fn.call(this, arg);
        cache.set(key, result);
        return result;
    };
    memoizedFn.cache = cache;
    return memoizedFn;
}

function ary(func, n) {
    return function (...args) {
        return func.apply(this, args.slice(0, n));
    };
}

function unary(func) {
    return ary(func, 1);
}

function partial(func, ...partialArgs) {
    return function (...providedArgs) {
        const args = [];
        let startIndex = 0;
        for (let i = 0; i < partialArgs.length; i++) {
            const arg = partialArgs[i];
            if (arg === partial.placeholder) {
                args.push(providedArgs[startIndex++]);
            }
            else {
                args.push(arg);
            }
        }
        for (let i = startIndex; i < providedArgs.length; i++) {
            args.push(providedArgs[i]);
        }
        return func.apply(this, args);
    };
}
const partialPlaceholder = Symbol('partial.placeholder');
partial.placeholder = partialPlaceholder;

function partialRight(func, ...partialArgs) {
    return function (...providedArgs) {
        const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;
        const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
        const args = [];
        let providedIndex = 0;
        for (let i = 0; i < rangeLength; i++) {
            args.push(providedArgs[providedIndex++]);
        }
        for (let i = 0; i < partialArgs.length; i++) {
            const arg = partialArgs[i];
            if (arg === partialRight.placeholder) {
                args.push(providedArgs[providedIndex++]);
            }
            else {
                args.push(arg);
            }
        }
        return func.apply(this, args);
    };
}
const partialRightPlaceholder = Symbol('partialRight.placeholder');
partialRight.placeholder = partialRightPlaceholder;

function rest(func, startIndex = func.length - 1) {
    return function (...args) {
        const rest = args.slice(startIndex);
        const params = args.slice(0, startIndex);
        while (params.length < startIndex) {
            params.push(undefined);
        }
        return func.apply(this, [...params, rest]);
    };
}

exports.after = after;
exports.ary = ary;
exports.before = before;
exports.debounce = debounce;
exports.memoize = memoize;
exports.negate = negate;
exports.noop = noop;
exports.once = once;
exports.partial = partial;
exports.partialRight = partialRight;
exports.rest = rest;
exports.throttle = throttle;
exports.unary = unary;
