'use strict';

const isTypedArray = require('./isTypedArray-BBEkFl.js');

function omit(obj, keys) {
    const result = { ...obj };
    for (const key of keys) {
        delete result[key];
    }
    return result;
}

function omitBy(obj, shouldOmit) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        if (shouldOmit(value, key)) {
            continue;
        }
        result[key] = value;
    }
    return result;
}

function pick(obj, keys) {
    const result = {};
    for (const key of keys) {
        result[key] = obj[key];
    }
    return result;
}

function pickBy(obj, shouldPick) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        if (!shouldPick(value, key)) {
            continue;
        }
        result[key] = value;
    }
    return result;
}

function invert(obj) {
    const result = {};
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        result[value] = key;
    }
    return result;
}

function clone(obj) {
    if (isPrimitive(obj)) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.slice();
    }
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    if (obj instanceof Map) {
        const result = new Map();
        for (const [key, value] of obj) {
            result.set(key, value);
        }
        return result;
    }
    if (obj instanceof Set) {
        const result = new Set();
        for (const value of obj) {
            result.add(value);
        }
        return result;
    }
    if (typeof obj === 'object') {
        const prototype = Object.getPrototypeOf(obj);
        const result = Object.create(prototype);
        return Object.assign(result, obj);
    }
    return obj;
}
function isPrimitive(value) {
    return value == null || (typeof value !== 'object' && typeof value !== 'function');
}

function flattenObject(object) {
    return flattenObjectImpl(object);
}
function flattenObjectImpl(object, prefix = '') {
    const result = {};
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        const prefixedKey = prefix ? `${prefix}.${key}` : key;
        if (isTypedArray.isPlainObject(value) && Object.keys(value).length > 0) {
            Object.assign(result, flattenObjectImpl(value, prefixedKey));
            continue;
        }
        if (Array.isArray(value)) {
            for (let index = 0; index < value.length; index++) {
                result[`${prefixedKey}.${index}`] = value[index];
            }
            continue;
        }
        result[prefixedKey] = value;
    }
    return result;
}

function mapKeys(object, getNewKey) {
    const result = {};
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        result[getNewKey(value, key, object)] = value;
    }
    return result;
}

function mapValues(object, getNewValue) {
    const result = {};
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        result[key] = getNewValue(value, key, object);
    }
    return result;
}

function cloneDeep(obj) {
    return cloneDeepImpl(obj);
}
function cloneDeepImpl(obj, stack = new Map()) {
    if (isTypedArray.isPrimitive(obj)) {
        return obj;
    }
    if (stack.has(obj)) {
        return stack.get(obj);
    }
    if (Array.isArray(obj)) {
        const result = new Array(obj.length);
        stack.set(obj, result);
        for (let i = 0; i < obj.length; i++) {
            result[i] = cloneDeepImpl(obj[i], stack);
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'index')) {
            result.index = obj.index;
        }
        if (Object.prototype.hasOwnProperty.call(obj, 'input')) {
            result.input = obj.input;
        }
        return result;
    }
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
        const result = new RegExp(obj.source, obj.flags);
        result.lastIndex = obj.lastIndex;
        return result;
    }
    if (obj instanceof Map) {
        const result = new Map();
        stack.set(obj, result);
        for (const [key, value] of obj.entries()) {
            result.set(key, cloneDeepImpl(value, stack));
        }
        return result;
    }
    if (obj instanceof Set) {
        const result = new Set();
        stack.set(obj, result);
        for (const value of obj.values()) {
            result.add(cloneDeepImpl(value, stack));
        }
        return result;
    }
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {
        return obj.subarray();
    }
    if (isTypedArray.isTypedArray(obj)) {
        const result = new (Object.getPrototypeOf(obj).constructor)(obj.length);
        stack.set(obj, result);
        for (let i = 0; i < obj.length; i++) {
            result[i] = cloneDeepImpl(obj[i], stack);
        }
        return result;
    }
    if (obj instanceof ArrayBuffer || (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {
        return obj.slice(0);
    }
    if (obj instanceof DataView) {
        const result = new DataView(obj.buffer.slice(0));
        stack.set(obj, result);
        copyProperties(result, obj, stack);
        return result;
    }
    if (typeof File !== 'undefined' && obj instanceof File) {
        const result = new File([obj], obj.name, { type: obj.type });
        stack.set(obj, result);
        copyProperties(result, obj, stack);
        return result;
    }
    if (obj instanceof Blob) {
        const result = new Blob([obj], { type: obj.type });
        stack.set(obj, result);
        copyProperties(result, obj, stack);
        return result;
    }
    if (obj instanceof Error) {
        const result = new obj.constructor();
        stack.set(obj, result);
        result.message = obj.message;
        result.name = obj.name;
        result.stack = obj.stack;
        result.cause = obj.cause;
        copyProperties(result, obj, stack);
        return result;
    }
    if (typeof obj === 'object' && obj !== null) {
        const result = {};
        stack.set(obj, result);
        copyProperties(result, obj, stack);
        return result;
    }
    return obj;
}
function copyProperties(target, source, stack) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(source, key);
        if (descriptor?.writable || descriptor?.set) {
            target[key] = cloneDeepImpl(source[key], stack);
        }
    }
}

function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}

function merge(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
        const key = sourceKeys[i];
        const sourceValue = source[key];
        const targetValue = target[key];
        if (Array.isArray(sourceValue)) {
            target[key] = merge(targetValue ?? [], sourceValue);
        }
        else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
            target[key] = merge(targetValue ?? {}, sourceValue);
        }
        else if (targetValue === undefined || sourceValue !== undefined) {
            target[key] = sourceValue;
        }
    }
    return target;
}

function toMerged(target, source) {
    return merge(cloneDeep(target), source);
}

exports.clone = clone;
exports.cloneDeep = cloneDeep;
exports.copyProperties = copyProperties;
exports.flattenObject = flattenObject;
exports.invert = invert;
exports.isObjectLike = isObjectLike;
exports.mapKeys = mapKeys;
exports.mapValues = mapValues;
exports.merge = merge;
exports.omit = omit;
exports.omitBy = omitBy;
exports.pick = pick;
exports.pickBy = pickBy;
exports.toMerged = toMerged;
